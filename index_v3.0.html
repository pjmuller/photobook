<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Family Album Creator</title>
    
    <!-- Dependencies -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css" rel="stylesheet">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    
    <style>
        :root {
            --page-outer-margin: 20px;
            --page-width: 730px;
            --page-height: 598px;
            --page-gutter: 10px;
            --image-bank-height: 170px;
        }

        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            background-color: #212529;
            color: #dee2e6;
        }

        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        /* --- Initial State --- */
        .initial-state-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
        }

        /* --- Loading Spinner --- */
        .loading-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        /* --- Main Layout --- */
        .main-content {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }

        /* --- Top Controls --- */
        .top-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 100;
        }

        /* --- Page Number --- */
        .page-number-display {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 0.9rem;
            z-index: 100;
        }

        /* --- Spread Viewer --- */
        .spread-viewer {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0;
            padding: var(--page-outer-margin);
            box-sizing: content-box;
        }

        .spread-viewer .page-container {
            position: relative;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        .spread-viewer .page-container.left-page {
            box-shadow: -2px 4px 15px rgba(0,0,0,0.4);
        }
        .spread-viewer .page-container.right-page {
            box-shadow: 2px 4px 15px rgba(0,0,0,0.4);
        }

        .spread-center-line {
            width: 2px;
            height: calc(var(--page-height) + 4px);
            background: linear-gradient(to right, rgba(0,0,0,0.4), rgba(0,0,0,0) 50%, rgba(0,0,0,0.4));
            position: relative;
            z-index: 10;
        }

        /* --- Page Display --- */
        .page-display {
            width: var(--page-width);
            height: var(--page-height);
            background-color: #fff;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .page-row {
            display: flex;
        }

        .gutter {
            background-color: #fff;
        }
        .gutter.row-gutter {
            cursor: row-resize;
        }
        .gutter.col-gutter {
            cursor: col-resize;
        }
        .gutter:hover {
            background-color: #0dcaf0; /* A highlight color */
        }

        /* --- Cell Display --- */
        .cell-display {
            background-color: #e9ecef;
            overflow: hidden;
            position: relative;
        }
        .cell-display.drag-over {
            outline: 3px dashed #0d6efd;
            outline-offset: -3px;
        }
        .cell-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px dashed #adb5bd;
            color: #6c757d;
            font-size: 1.2rem;
            box-sizing: border-box;
        }
        .cell-display img {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: top left;
            user-select: none;
            pointer-events: none;
        }
        .cell-display:hover .cell-image-overlay {
            opacity: 1;
        }
        .cell-image-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.3);
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            cursor: grab;
        }
        .cell-image-overlay:active {
            cursor: grabbing;
        }

        /* --- Layout Changer --- */
        .layout-changer {
            position: absolute;
            top: 8px;
            z-index: 50;
        }
        .layout-changer.left { left: 8px; }
        .layout-changer.right { right: 8px; }

        /* --- Image Bank --- */
        .image-bank {
            height: var(--image-bank-height);
            width: 100%;
            background-color: #1a1d20;
            border-top: 1px solid #495057;
            display: flex;
            align-items: center;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 0 10px;
            flex-shrink: 0;
        }
        .image-bank::-webkit-scrollbar { height: 8px; }
        .image-bank::-webkit-scrollbar-track { background: #212529; }
        .image-bank::-webkit-scrollbar-thumb { background: #495057; border-radius: 4px; }

        .image-bank-thumb {
            height: 150px;
            margin: 0 5px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            transition: transform 0.2s ease-in-out, filter 0.2s ease-in-out;
            object-fit: cover; /* This is for display, JS calculates width */
        }
        .image-bank-thumb.available {
            cursor: grab;
        }
        .image-bank-thumb.available:hover {
            transform: scale(1.08);
        }
        .image-bank-thumb.used {
            cursor: pointer;
            filter: grayscale(90%) brightness(0.6);
        }
        .image-bank-thumb.used:hover {
            filter: grayscale(0%) brightness(1);
            transform: scale(1.05);
        }

        /* --- Crop Editor --- */
        .crop-editor-modal .modal-body {
            padding: 0;
            height: 70vh;
            background-color: #343a40;
        }
        .crop-editor-container {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
            cursor: move;
        }
        .crop-editor-container img {
            position: absolute;
            transform-origin: center center;
            cursor: move;
            user-select: none;
            pointer-events: none;
        }
        .crop-editor-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 50%;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
    </style>
</head>
<body>

    <div id="app">
        <!-- Initial State -->
        <div v-if="!directoryHandle" class="initial-state-container">
            <button @click="selectFolder" class="btn btn-primary btn-lg">
                <i class="bi bi-folder2-open"></i> Select Image Folder
            </button>
        </div>

        <!-- Main App UI -->
        <template v-else>
            <!-- Top Controls -->
            <div class="top-controls">
                <div class="btn-group me-2" role="group">
                    <button @click="navigateSpread(-1)" :disabled="!canNavigatePrev" class="btn btn-outline-secondary" data-bs-toggle="tooltip" title="Previous Spread">
                        <i class="bi bi-arrow-left"></i>
                    </button>
                    <button @click="navigateSpread(1)" :disabled="!canNavigateNext" class="btn btn-outline-secondary" data-bs-toggle="tooltip" title="Next Spread">
                        <i class="bi bi-arrow-right"></i>
                    </button>
                </div>
                <div class="btn-group" role="group">
                    <button @click="addSpread" class="btn btn-outline-secondary" data-bs-toggle="tooltip" title="Add New Spread">
                        <i class="bi bi-plus-lg"></i>
                    </button>
                    <button @click="deleteSpread" :disabled="!isSpreadDeletable" class="btn btn-outline-secondary" data-bs-toggle="tooltip" title="Delete Current Spread">
                        <i class="bi bi-trash"></i>
                    </button>
                    <div class="btn-group" role="group">
                        <button type="button" class="btn btn-outline-secondary dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false" :disabled="!isSpreadDeletable" data-bs-toggle="tooltip" title="Move Spread">
                            <i class="bi bi-arrow-left-right"></i>
                        </button>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="#" @click.prevent="moveSpread(-1)" :class="{ disabled: !canMoveSpreadLeft }"><i class="bi bi-arrow-bar-left"></i> Move Left</a></li>
                            <li><a class="dropdown-item" href="#" @click.prevent="moveSpread(1)" :class="{ disabled: !canMoveSpreadRight }"><i class="bi bi-arrow-bar-right"></i> Move Right</a></li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Main Content -->
            <main class="main-content">
                <spread-viewer 
                    :spread="currentSpread"
                    :is-first-page="isFirstPage"
                    :is-last-page="isLastPage"
                    @update:page="updatePage"
                    @image-dropped="handleImageDrop"
                    @cell-drag-start="handleCellDragStart"
                    @cell-dbl-click="openCropEditor"
                />
            </main>

            <!-- Page Number -->
            <div v-if="pageNumberDisplay" class="page-number-display">
                {{ pageNumberDisplay }}
            </div>

            <!-- Image Bank -->
            <image-bank 
                :images="imageList" 
                :used-image-paths="usedImagePaths"
                @image-drag-start="handleImageBankDragStart"
                @image-click="navigateToImagePage"
            />
        </template>

        <!-- Loading Overlay -->
        <div v-if="isLoading" class="loading-overlay">
            <div class="spinner-border text-light" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>

        <!-- Crop Editor Modal -->
        <crop-editor ref="cropEditor" @save="saveCrop" />
    </div>

    <!-- VUE TEMPLATES -->

    <!-- Spread Viewer Component -->
    <template id="spread-viewer-template">
        <div class="spread-viewer">
            <!-- Left Page -->
            <div v-if="spread.left" class="page-container left-page">
                <page-display
                    :page="spread.left"
                    :page-index="spread.left.index"
                    :is-single="isFirstPage || isLastPage"
                    :is-first-or-last-page="isFirstPage || isLastPage"
                    position="left"
                    @update:page="p => $emit('update:page', p)"
                    @image-dropped="(payload) => $emit('image-dropped', payload)"
                    @cell-drag-start="(payload) => $emit('cell-drag-start', payload)"
                    @cell-dbl-click="(payload) => $emit('cell-dbl-click', payload)"
                />
            </div>

            <!-- Gutter -->
            <div v-if="spread.left && spread.right" class="spread-center-line"></div>

            <!-- Right Page -->
            <div v-if="spread.right" class="page-container right-page">
                <page-display
                    :page="spread.right"
                    :page-index="spread.right.index"
                    :is-single="isFirstPage || isLastPage"
                    :is-first-or-last-page="isFirstPage || isLastPage"
                    position="right"
                    @update:page="p => $emit('update:page', p)"
                    @image-dropped="(payload) => $emit('image-dropped', payload)"
                    @cell-drag-start="(payload) => $emit('cell-drag-start', payload)"
                    @cell-dbl-click="(payload) => $emit('cell-dbl-click', payload)"
                />
            </div>
        </div>
    </template>

    <!-- Page Display Component -->
    <template id="page-display-template">
        <div class="page-display">
            <!-- Layout Changer -->
            <div v-if="!isFirstOrLastPage" class="layout-changer" :class="position">
                <div class="dropdown">
                    <button class="btn btn-sm btn-secondary" type="button" data-bs-toggle="dropdown" aria-expanded="false" data-bs-toggle="tooltip" title="Change Layout">
                        <i class="bi bi-grid-fill"></i>
                    </button>
                    <ul class="dropdown-menu">
                        <li v-for="layout in availableLayouts" :key="layout">
                            <a class="dropdown-item" href="#" @click.prevent="changeLayout(layout)">{{ layout }}</a>
                        </li>
                    </ul>
                </div>
            </div>

            <template v-for="(row, rowIndex) in page.rows">
                <div class="page-row" :style="{ height: row.height + 'px' }">
                    <template v-for="(cell, cellIndex) in row.cells">
                        <cell-display
                            :cell="cell"
                            :cell-coords="{ pageIndex, rowIndex, cellIndex }"
                            :style="{ width: cell.width + 'px' }"
                            @image-dropped="(payload) => $emit('image-dropped', payload)"
                            @cell-drag-start="(payload) => $emit('cell-drag-start', payload)"
                            @cell-dbl-click="(payload) => $emit('cell-dbl-click', payload)"
                        />
                        <div v-if="cellIndex < row.cells.length - 1"
                             class="gutter col-gutter"
                             :style="{ width: PAGE_GUTTER + 'px', height: row.height + 'px' }"
                             @mousedown="e => startColResize(e, rowIndex, cellIndex)">
                        </div>
                    </template>
                </div>
                <div v-if="rowIndex < page.rows.length - 1"
                     class="gutter row-gutter"
                     :style="{ height: PAGE_GUTTER + 'px', width: PAGE_WIDTH + 'px' }"
                     @mousedown="e => startRowResize(e, rowIndex)">
                </div>
            </template>
        </div>
    </template>

    <!-- Cell Display Component -->
    <template id="cell-display-template">
        <div class="cell-display"
             :class="{ 'drag-over': isDragOver }"
             @dragover.prevent="isDragOver = true"
             @dragleave.prevent="isDragOver = false"
             @drop.prevent="onDrop"
             @dblclick="onDblClick">
            <div v-if="!cell.path" class="cell-placeholder">
                <i class="bi bi-image"></i>Â  Drop image
            </div>
            <template v-else>
                <div class="cell-image-overlay"
                     draggable="true"
                     @dragstart="onDragStart">
                </div>
                <img :src="imageSrc" :style="imageTransform" />
            </template>
        </div>
    </template>

    <!-- Image Bank Component -->
    <template id="image-bank-template">
        <div class="image-bank">
            <img v-for="image in images"
                 :key="image.path"
                 :src="image.url"
                 :class="{ 'image-bank-thumb': true, 'used': isUsed(image.path), 'available': !isUsed(image.path) }"
                 :style="{ width: image.thumbWidth + 'px' }"
                 :draggable="!isUsed(image.path)"
                 @dragstart="e => onDragStart(e, image)"
                 @click="onClick(image.path)">
        </div>
    </template>

    <!-- Crop Editor Modal Component -->
    <template id="crop-editor-template">
        <div class="modal fade" ref="modal" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog modal-xl modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-body">
                        <div v-if="image"
                             class="crop-editor-container"
                             ref="container"
                             @mousedown="startPan">
                            <img :src="image.url" :style="imageStyle" />
                            <div class="crop-editor-controls" @mousedown.stop>
                                <i class="bi bi-zoom-out"></i>
                                <input type="range" class="form-range" min="1" max="3" step="0.01" v-model.number="zoom">
                                <i class="bi bi-zoom-in"></i>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" @click="save">Save Changes</button>
                    </div>
                </div>
            </div>
        </div>
    </template>

    <!-- SCRIPTS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // --- CONSTANTS ---
        const PHOTOBOOK_VERSION = "2.0";
        const PAGE_OUTER_MARGIN = 20;
        const PAGE_WIDTH = 730;
        const PAGE_HEIGHT = 598;
        const ROW_MIN_HEIGHT = 100;
        const CELL_MIN_WIDTH = 100;
        const PAGE_GUTTER = 10;

        const { createApp, ref, reactive, computed, onMounted, nextTick } = Vue;

        // --- CROP EDITOR COMPONENT ---
        const CropEditor = {
            template: '#crop-editor-template',
            setup(props, { emit }) {
                const modal = ref(null);
                const container = ref(null);
                const bsModal = ref(null);

                const image = ref(null);
                const cell = ref(null);
                const focalPoint = ref({ x: 0.5, y: 0.5 });
                const zoom = ref(1.0);

                let panState = {
                    isPanning: false,
                    startX: 0,
                    startY: 0,
                    startFocalX: 0,
                    startFocalY: 0,
                };

                onMounted(() => {
                    bsModal.value = new bootstrap.Modal(modal.value);
                });

                const open = (img, c) => {
                    image.value = img;
                    cell.value = c;
                    focalPoint.value = { ...c.focalPoint };
                    zoom.value = c.zoom;
                    bsModal.value.show();
                };

                const imageStyle = computed(() => {
                    if (!image.value || !cell.value || !container.value) return {};
                    
                    const imgW = image.value.width;
                    const imgH = image.value.height;
                    const containerW = container.value.clientWidth;
                    const containerH = container.value.clientHeight;

                    const scaleX = containerW / imgW;
                    const scaleY = containerH / imgH;
                    const scale = Math.max(scaleX, scaleY) * zoom.value;

                    const scaledW = imgW * scale;
                    const scaledH = imgH * scale;

                    const focalX_px = focalPoint.value.x * scaledW;
                    const focalY_px = focalPoint.value.y * scaledH;

                    let left = (containerW / 2) - focalX_px;
                    let top = (containerH / 2) - focalY_px;

                    // Clamp
                    left = Math.min(0, Math.max(left, containerW - scaledW));
                    top = Math.min(0, Math.max(top, containerH - scaledH));

                    return {
                        width: `${imgW}px`,
                        height: `${imgH}px`,
                        transform: `translate(${left}px, ${top}px) scale(${scale})`,
                    };
                });

                const startPan = (e) => {
                    if (e.button !== 0) return;
                    panState.isPanning = true;
                    panState.startX = e.clientX;
                    panState.startY = e.clientY;
                    panState.startFocalX = focalPoint.value.x;
                    panState.startFocalY = focalPoint.value.y;
                    document.addEventListener('mousemove', onPan);
                    document.addEventListener('mouseup', endPan);
                };

                const onPan = (e) => {
                    if (!panState.isPanning) return;
                    const dx = e.clientX - panState.startX;
                    const dy = e.clientY - panState.startY;

                    const imgW = image.value.width;
                    const imgH = image.value.height;
                    const containerW = container.value.clientWidth;
                    const containerH = container.value.clientHeight;

                    const scaleX = containerW / imgW;
                    const scaleY = containerH / imgH;
                    const scale = Math.max(scaleX, scaleY) * zoom.value;

                    const scaledW = imgW * scale;
                    const scaledH = imgH * scale;

                    const focalDx = -dx / scaledW;
                    const focalDy = -dy / scaledH;

                    focalPoint.value.x = Math.max(0, Math.min(1, panState.startFocalX + focalDx));
                    focalPoint.value.y = Math.max(0, Math.min(1, panState.startFocalY + focalDy));
                };

                const endPan = () => {
                    panState.isPanning = false;
                    document.removeEventListener('mousemove', onPan);
                    document.removeEventListener('mouseup', endPan);
                };

                const save = () => {
                    emit('save', {
                        focalPoint: { ...focalPoint.value },
                        zoom: zoom.value,
                    });
                    bsModal.value.hide();
                };

                return { modal, container, image, zoom, open, save, startPan, imageStyle };
            },
            emits: ['save'],
        };

        // --- IMAGE BANK COMPONENT ---
        const ImageBank = {
            template: '#image-bank-template',
            props: ['images', 'usedImagePaths'],
            emits: ['imageDragStart', 'imageClick'],
            setup(props, { emit }) {
                const isUsed = (path) => props.usedImagePaths.has(path);
                const onDragStart = (event, image) => emit('imageDragStart', { event, image });
                const onClick = (path) => {
                    if (isUsed(path)) {
                        emit('imageClick', path);
                    }
                };
                return { isUsed, onDragStart, onClick };
            }
        };

        // --- CELL DISPLAY COMPONENT ---
        const CellDisplay = {
            template: '#cell-display-template',
            props: ['cell', 'cellCoords'],
            inject: ['getImageByPath', 'getApp'],
            emits: ['imageDropped', 'cellDragStart', 'cellDblClick'],
            setup(props, { emit }) {
                const isDragOver = ref(false);
                const app = getApp();

                const image = computed(() => props.cell.path ? app.getImageByPath(props.cell.path) : null);
                
                const imageSrc = computed(() => image.value ? image.value.url : '');

                const imageTransform = computed(() => {
                    if (!props.cell.path || !props.cell.crop_width) return {};
                    
                    const cellW = props.cell.width;
                    const { crop_x, crop_y, crop_width } = props.cell;
                    
                    const scale = cellW / crop_width;
                    const translateX = -crop_x * scale;
                    const translateY = -crop_y * scale;

                    return {
                        transform: `scale(${scale}) translate(${translateX}px, ${translateY}px)`,
                    };
                });

                const onDrop = (event) => {
                    isDragOver.value = false;
                    emit('imageDropped', { event, coords: props.cellCoords });
                };

                const onDragStart = (event) => {
                    emit('cellDragStart', { event, coords: props.cellCoords });
                };

                const onDblClick = () => {
                    if (props.cell.path) {
                        emit('cellDblClick', { coords: props.cellCoords });
                    }
                };

                return { isDragOver, imageSrc, imageTransform, onDrop, onDragStart, onDblClick };
            }
        };

        // --- PAGE DISPLAY COMPONENT ---
        const PageDisplay = {
            template: '#page-display-template',
            components: { CellDisplay },
            props: ['page', 'pageIndex', 'isSingle', 'isFirstOrLastPage', 'position'],
            emits: ['update:page', 'imageDropped', 'cellDragStart', 'cellDblClick'],
            setup(props, { emit }) {
                const availableLayouts = ["1", "2-2", "2-3", "3-2"];

                const changeLayout = (newLayout) => {
                    const updatedPage = JSON.parse(JSON.stringify(props.page));
                    emit('update:page', { ...updatedPage, layout: newLayout });
                };

                const startRowResize = (e, rowIndex) => {
                    const startY = e.clientY;
                    const row1 = props.page.rows[rowIndex];
                    const row2 = props.page.rows[rowIndex + 1];
                    const initialHeight1 = row1.height;
                    const initialHeight2 = row2.height;

                    const onMouseMove = (moveEvent) => {
                        const dy = moveEvent.clientY - startY;
                        let newHeight1 = initialHeight1 + dy;
                        let newHeight2 = initialHeight2 - dy;

                        if (newHeight1 < ROW_MIN_HEIGHT) {
                            newHeight1 = ROW_MIN_HEIGHT;
                            newHeight2 = initialHeight1 + initialHeight2 - newHeight1;
                        }
                        if (newHeight2 < ROW_MIN_HEIGHT) {
                            newHeight2 = ROW_MIN_HEIGHT;
                            newHeight1 = initialHeight1 + initialHeight2 - newHeight2;
                        }
                        
                        const updatedPage = JSON.parse(JSON.stringify(props.page));
                        updatedPage.rows[rowIndex].height = newHeight1;
                        updatedPage.rows[rowIndex + 1].height = newHeight2;
                        emit('update:page', updatedPage);
                    };

                    const onMouseUp = () => {
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    };

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                };

                const startColResize = (e, rowIndex, cellIndex) => {
                    const startX = e.clientX;
                    const cell1 = props.page.rows[rowIndex].cells[cellIndex];
                    const cell2 = props.page.rows[rowIndex].cells[cellIndex + 1];
                    const initialWidth1 = cell1.width;
                    const initialWidth2 = cell2.width;

                    const onMouseMove = (moveEvent) => {
                        const dx = moveEvent.clientX - startX;
                        let newWidth1 = initialWidth1 + dx;
                        let newWidth2 = initialWidth2 - dx;

                        if (newWidth1 < CELL_MIN_WIDTH) {
                            newWidth1 = CELL_MIN_WIDTH;
                            newWidth2 = initialWidth1 + initialWidth2 - newWidth1;
                        }
                        if (newWidth2 < CELL_MIN_WIDTH) {
                            newWidth2 = CELL_MIN_WIDTH;
                            newWidth1 = initialWidth1 + initialWidth2 - newWidth2;
                        }

                        const updatedPage = JSON.parse(JSON.stringify(props.page));
                        updatedPage.rows[rowIndex].cells[cellIndex].width = newWidth1;
                        updatedPage.rows[rowIndex].cells[cellIndex + 1].width = newWidth2;
                        emit('update:page', updatedPage);
                    };

                    const onMouseUp = () => {
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    };

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                };

                return { 
                    PAGE_WIDTH, PAGE_HEIGHT, PAGE_GUTTER,
                    availableLayouts, changeLayout, startRowResize, startColResize 
                };
            }
        };

        // --- SPREAD VIEWER COMPONENT ---
        const SpreadViewer = {
            template: '#spread-viewer-template',
            components: { PageDisplay },
            props: ['spread', 'isFirstPage', 'isLastPage'],
            emits: ['update:page', 'imageDropped', 'cellDragStart', 'cellDblClick'],
        };

        // --- MAIN VUE APP ---
        const app = createApp({
            components: { SpreadViewer, ImageBank, CropEditor },
            setup() {
                // --- STATE ---
                const isLoading = ref(false);
                const directoryHandle = ref(null);
                const album = reactive({
                    photobook_version: PHOTOBOOK_VERSION,
                    pages: []
                });
                const imageList = ref([]); // { path, url, width, height, thumbWidth, dateTime }
                const currentSpreadIndex = ref(0);
                const draggedItem = ref(null); // { type: 'bank' | 'cell', data: any }
                const cropEditor = ref(null);
                let tooltips = [];

                // --- COMPUTED PROPERTIES ---
                const totalSpreads = computed(() => {
                    if (album.pages.length <= 1) return album.pages.length;
                    return 1 + Math.ceil((album.pages.length - 2) / 2) + (album.pages.length > 1 ? 1 : 0);
                });

                const currentSpread = computed(() => {
                    if (album.pages.length === 0) return { left: null, right: null };

                    // First page (single)
                    if (currentSpreadIndex.value === 0) {
                        return { left: null, right: { ...album.pages[0], index: 0 } };
                    }
                    // Last page (single)
                    if (currentSpreadIndex.value === totalSpreads.value - 1 && album.pages.length % 2 === 0) {
                        const lastPageIndex = album.pages.length - 1;
                        return { left: { ...album.pages[lastPageIndex], index: lastPageIndex }, right: null };
                    }
                    // Double page spread
                    const leftPageIndex = 1 + (currentSpreadIndex.value - 1) * 2;
                    const rightPageIndex = leftPageIndex + 1;
                    
                    return {
                        left: { ...album.pages[leftPageIndex], index: leftPageIndex },
                        right: rightPageIndex < album.pages.length ? { ...album.pages[rightPageIndex], index: rightPageIndex } : null,
                    };
                });

                const isFirstPage = computed(() => currentSpreadIndex.value === 0);
                const isLastPage = computed(() => currentSpreadIndex.value === totalSpreads.value - 1 && album.pages.length > 1);
                const isSpreadDeletable = computed(() => !isFirstPage.value && !isLastPage.value);

                const canNavigatePrev = computed(() => currentSpreadIndex.value > 0);
                const canNavigateNext = computed(() => currentSpreadIndex.value < totalSpreads.value - 1);
                
                const canMoveSpreadLeft = computed(() => isSpreadDeletable.value && currentSpreadIndex.value > 1);
                const canMoveSpreadRight = computed(() => {
                    if (!isSpreadDeletable.value) return false;
                    const isLastSpread = currentSpreadIndex.value === totalSpreads.value - 2;
                    return !isLastSpread;
                });

                const pageNumberDisplay = computed(() => {
                    if (album.pages.length === 0) return "";
                    const total = album.pages.length;
                    if (isFirstPage.value) return `Page 1 / ${total}`;
                    if (isLastPage.value) return `Page ${total} / ${total}`;
                    
                    const left = currentSpread.value.left.index + 1;
                    const right = currentSpread.value.right.index + 1;
                    return `Pages ${left}-${right} / ${total}`;
                });

                const usedImagePaths = computed(() => {
                    const paths = new Set();
                    album.pages.forEach(p => p.rows.forEach(r => r.cells.forEach(c => {
                        if (c.path) paths.add(c.path);
                    })));
                    return paths;
                });

                // --- METHODS ---

                // --- File & Album Handling ---
                const selectFolder = async () => {
                    try {
                        isLoading.value = true;
                        const handle = await window.showDirectoryPicker();
                        
                        const jpgFiles = [];
                        for await (const entry of handle.values()) {
                            if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.jpg')) {
                                jpgFiles.push(entry);
                            }
                        }

                        if (jpgFiles.length === 0) {
                            alert('The selected folder contains no JPG images. Please select another folder.');
                            isLoading.value = false;
                            return;
                        }

                        directoryHandle.value = handle;
                        await loadImages(jpgFiles);
                        await loadAlbum();
                        
                        nextTick(initTooltips);

                    } catch (err) {
                        console.error('Error selecting folder:', err);
                        if (err.name !== 'AbortError') {
                            alert('Could not access the folder. Please check permissions and try again.');
                        }
                    } finally {
                        isLoading.value = false;
                    }
                };

                const loadImages = async (fileHandles) => {
                    const imagePromises = fileHandles.map(async (fileHandle) => {
                        const file = await fileHandle.getFile();
                        const url = URL.createObjectURL(file);
                        
                        const dimensions = await new Promise(resolve => {
                            const img = new Image();
                            img.onload = () => resolve({ width: img.width, height: img.height });
                            img.src = url;
                        });

                        const dateTime = await new Promise(resolve => {
                            EXIF.getData(file, function() {
                                resolve(EXIF.getTag(this, "DateTimeOriginal"));
                            });
                        });

                        return {
                            path: file.name,
                            url,
                            ...dimensions,
                            thumbWidth: (150 / dimensions.height) * dimensions.width,
                            dateTime: dateTime ? new Date(dateTime.replace(':', '-').replace(':', '-')) : null,
                        };
                    });

                    const loaded = await Promise.all(imagePromises);
                    loaded.sort((a, b) => {
                        if (a.dateTime && b.dateTime) return a.dateTime - b.dateTime;
                        if (a.dateTime) return -1;
                        if (b.dateTime) return 1;
                        return a.path.localeCompare(b.path);
                    });
                    imageList.value = loaded;
                };

                const loadAlbum = async () => {
                    try {
                        const fileHandle = await directoryHandle.value.getFileHandle('album.json');
                        const file = await fileHandle.getFile();
                        const content = await file.text();
                        const data = JSON.parse(content);

                        if (data.photobook_version !== PHOTOBOOK_VERSION) {
                            alert(`Error: Incompatible album version. Expected ${PHOTOBOOK_VERSION}, found ${data.photobook_version}. Please remove album.json and reload.`);
                            directoryHandle.value = null;
                            return;
                        }
                        Object.assign(album, data);
                    } catch (e) {
                        if (e.name === 'NotFoundError') {
                            console.log('album.json not found, creating a new one.');
                            createDefaultAlbum();
                            await saveAlbum();
                        } else {
                            console.error('Error loading album.json:', e);
                            alert('There was an error reading album.json.');
                        }
                    }
                };

                const saveAlbum = async () => {
                    if (!directoryHandle.value) return;
                    try {
                        const fileHandle = await directoryHandle.value.getFileHandle('album.json', { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(JSON.stringify(album, null, 2));
                        await writable.close();
                    } catch (err) {
                        console.error('Failed to save album:', err);
                        alert('Error: Could not save changes to album.json.');
                    }
                };
                
                const createDefaultAlbum = () => {
                    album.pages.splice(0, album.pages.length);
                    album.pages.push(generatePage("1")); // First page
                    album.pages.push(generatePage("2-3")); // Spread
                    album.pages.push(generatePage("3-2")); // Spread
                    album.pages.push(generatePage("1")); // Last page
                    currentSpreadIndex.value = 0;
                };

                // --- Page/Layout Generation ---
                const generatePage = (layout) => {
                    const page = { id: crypto.randomUUID(), layout, rows: [] };
                    updatePageLayout(page);
                    return page;
                };

                const updatePageLayout = (page) => {
                    const oldImages = [];
                    page.rows.forEach(r => r.cells.forEach(c => {
                        if (c.path) oldImages.push({ ...c });
                    }));
                    
                    const [rowsSpec, colsSpec] = page.layout.split('-').map(s => s.split('').map(Number));
                    const rowCount = rowsSpec.length;
                    const rowHeights = calculateDistribution(PAGE_HEIGHT, rowCount, PAGE_GUTTER);
                    
                    page.rows = [];
                    for (let i = 0; i < rowCount; i++) {
                        const cellCount = colsSpec[i];
                        const cellWidths = calculateDistribution(PAGE_WIDTH, cellCount, PAGE_GUTTER);
                        page.rows.push({
                            height: rowHeights[i],
                            cells: cellWidths.map(w => ({ width: w }))
                        });
                    }

                    // Try to place old images back
                    oldImages.forEach(img => {
                        for (const row of page.rows) {
                            for (const cell of row.cells) {
                                if (!cell.path) {
                                    Object.assign(cell, img);
                                    recalculateCropForCell(cell);
                                    return;
                                }
                            }
                        }
                    });
                };

                const calculateDistribution = (total, count, gutter) => {
                    if (count === 0) return [];
                    const net = total - (count - 1) * gutter;
                    const base = Math.floor(net / count);
                    const result = Array(count).fill(base);
                    const remainder = net - (base * count);
                    for (let i = 0; i < remainder; i++) {
                        result[i]++;
                    }
                    return result;
                };

                // --- Navigation & Page Actions ---
                const navigateSpread = (direction) => {
                    currentSpreadIndex.value += direction;
                };

                const addSpread = () => {
                    const newSpread = [generatePage("2-2"), generatePage("2-2")];
                    let insertIndex = album.pages.length -1;
                    if(!isLastPage.value) {
                        insertIndex = currentSpread.value.right ? currentSpread.value.right.index + 1 : currentSpread.value.left.index + 1;
                    }
                    album.pages.splice(insertIndex, 0, ...newSpread);
                    currentSpreadIndex.value = Math.ceil((insertIndex-1)/2) + 1;
                    saveAlbum();
                };

                const deleteSpread = () => {
                    if (!isSpreadDeletable.value) return;
                    if (confirm('Are you sure you want to delete this spread? This cannot be undone.')) {
                        const leftIndex = currentSpread.value.left.index;
                        album.pages.splice(leftIndex, 2);
                        currentSpreadIndex.value--;
                        saveAlbum();
                    }
                };

                const moveSpread = (direction) => {
                    const leftIndex = currentSpread.value.left.index;
                    const [spread] = album.pages.splice(leftIndex, 2);
                    album.pages.splice(leftIndex + (direction * 2), 0, spread, album.pages[leftIndex]);
                    currentSpreadIndex.value += direction;
                    saveAlbum();
                };

                const navigateToImagePage = (path) => {
                    for (let i = 0; i < album.pages.length; i++) {
                        const page = album.pages[i];
                        for (const row of page.rows) {
                            for (const cell of row.cells) {
                                if (cell.path === path) {
                                    if (i === 0) currentSpreadIndex.value = 0;
                                    else if (i === album.pages.length - 1) currentSpreadIndex.value = totalSpreads.value - 1;
                                    else currentSpreadIndex.value = 1 + Math.floor((i - 1) / 2);
                                    return;
                                }
                            }
                        }
                    }
                };

                // --- Image & Cell Handling ---
                const getImageByPath = (path) => imageList.value.find(img => img.path === path);

                const getCellByCoords = ({ pageIndex, rowIndex, cellIndex }) => {
                    return album.pages[pageIndex]?.rows[rowIndex]?.cells[cellIndex];
                };

                const updatePage = (updatedPageData) => {
                    const pageIndex = album.pages.findIndex(p => p.id === updatedPageData.id);
                    if (pageIndex === -1) return;

                    const oldPage = album.pages[pageIndex];
                    const newPage = JSON.parse(JSON.stringify(updatedPageData));

                    // If layout changed, re-generate it
                    if (oldPage.layout !== newPage.layout) {
                        handleLayoutChange(pageIndex, newPage.layout);
                    } else {
                        // It was a resize, just update and recalculate crops
                        album.pages[pageIndex] = newPage;
                        newPage.rows.forEach(row => {
                            row.cells.forEach(cell => {
                                if (cell.path) recalculateCropForCell(cell);
                            });
                        });
                    }
                    saveAlbum();
                };
                
                const handleLayoutChange = (pageIndex, newLayout) => {
                    const page = album.pages[pageIndex];
                    const oldLayout = page.layout;
                    
                    // Collect all images from the page before changing structure
                    const imagesInPage = [];
                    page.rows.forEach(r => r.cells.forEach(c => {
                        if (c.path) imagesInPage.push({ ...c });
                    }));
                    
                    // Specific switch strategies
                    if (newLayout === '1') {
                        page.layout = '1';
                        updatePageLayout(page);
                        if (imagesInPage.length > 0) {
                            Object.assign(page.rows[0].cells[0], imagesInPage[0]);
                            recalculateCropForCell(page.rows[0].cells[0]);
                        }
                    } else if (oldLayout === '1') {
                        page.layout = newLayout;
                        updatePageLayout(page);
                        if (imagesInPage.length > 0) {
                            Object.assign(page.rows[0].cells[0], imagesInPage[0]);
                            recalculateCropForCell(page.rows[0].cells[0]);
                        }
                    } else if ((oldLayout === '2-3' && newLayout === '3-2') || (oldLayout === '3-2' && newLayout === '2-3')) {
                        [page.rows[0], page.rows[1]] = [page.rows[1], page.rows[0]];
                        page.layout = newLayout;
                    } else {
                        // General case: re-generate layout and try to fit images back
                        page.layout = newLayout;
                        updatePageLayout(page);
                        
                        // Re-distribute images
                        let imageIdx = 0;
                        for (const row of page.rows) {
                            for (const cell of row.cells) {
                                if (imageIdx < imagesInPage.length) {
                                    Object.assign(cell, imagesInPage[imageIdx]);
                                    recalculateCropForCell(cell);
                                    imageIdx++;
                                }
                            }
                        }
                    }
                };

                const recalculateCropForCell = (cell) => {
                    const image = getImageByPath(cell.path);
                    if (!image) return;
                    
                    const { crop_x, crop_y, crop_width, crop_height } = calculateCrop(
                        image.width, image.height,
                        cell.width, cell.height,
                        cell.focalPoint, cell.zoom
                    );
                    
                    cell.crop_x = crop_x;
                    cell.crop_y = crop_y;
                    cell.crop_width = crop_width;
                    cell.crop_height = crop_height;
                };

                const calculateCrop = (imgW, imgH, cellW, cellH, focalPoint, zoom) => {
                    const imgAR = imgW / imgH;
                    const cellAR = cellW / cellH;

                    let baseCropW, baseCropH;
                    if (imgAR > cellAR) { // Image is wider than cell
                        baseCropH = imgH;
                        baseCropW = imgH * cellAR;
                    } else { // Image is narrower or same AR
                        baseCropW = imgW;
                        baseCropH = imgW / cellAR;
                    }

                    const finalCropW = baseCropW / zoom;
                    const finalCropH = baseCropH / zoom;

                    const focalX = focalPoint.x * imgW;
                    const focalY = focalPoint.y * imgH;

                    const crop_x = focalX - (finalCropW / 2);
                    const crop_y = focalY - (finalCropH / 2);

                    return {
                        crop_x: Math.max(0, Math.min(crop_x, imgW - finalCropW)),
                        crop_y: Math.max(0, Math.min(crop_y, imgH - finalCropH)),
                        crop_width: finalCropW,
                        crop_height: finalCropH,
                    };
                };

                // --- Drag & Drop ---
                const handleImageBankDragStart = ({ event, image }) => {
                    draggedItem.value = { type: 'bank', data: image };
                    event.dataTransfer.setData('text/plain', image.path);
                    event.dataTransfer.effectAllowed = 'copy';
                };

                const handleCellDragStart = ({ event, coords }) => {
                    draggedItem.value = { type: 'cell', data: coords };
                    const cell = getCellByCoords(coords);
                    event.dataTransfer.setData('text/plain', cell.path);
                    event.dataTransfer.effectAllowed = 'move';
                };

                const handleImageDrop = ({ event, coords }) => {
                    const targetCell = getCellByCoords(coords);
                    if (!targetCell) return;

                    const source = draggedItem.value;
                    if (!source) return;

                    if (source.type === 'bank') {
                        const image = source.data;
                        if (usedImagePaths.value.has(image.path)) return; // Can't use same image twice

                        targetCell.path = image.path;
                        targetCell.focalPoint = { x: 0.5, y: 0.5 };
                        targetCell.zoom = 1.0;
                        recalculateCropForCell(targetCell);
                    } else if (source.type === 'cell') {
                        const sourceCell = getCellByCoords(source.data);
                        if (sourceCell === targetCell) return;

                        // Swap
                        const temp = { ...targetCell };
                        Object.assign(targetCell, { ...sourceCell });
                        Object.assign(sourceCell, { path: temp.path, focalPoint: temp.focalPoint, zoom: temp.zoom });

                        if (targetCell.path) recalculateCropForCell(targetCell);
                        if (sourceCell.path) recalculateCropForCell(sourceCell);
                    }
                    
                    draggedItem.value = null;
                    saveAlbum();
                };
                
                // --- Cropping ---
                const openCropEditor = ({ coords }) => {
                    const cell = getCellByCoords(coords);
                    const image = getImageByPath(cell.path);
                    if (cell && image) {
                        cropEditor.value.open(image, cell);
                    }
                };

                const saveCrop = ({ focalPoint, zoom }) => {
                    const cell = getCellByCoords(cropEditor.value.cell);
                    if (cell) {
                        cell.focalPoint = focalPoint;
                        cell.zoom = zoom;
                        recalculateCropForCell(cell);
                        saveAlbum();
                    }
                };
                
                // --- Misc ---
                const initTooltips = () => {
                    tooltips.forEach(t => t.dispose());
                    tooltips = [];
                    const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
                    tooltipTriggerList.forEach(tooltipTriggerEl => {
                        tooltips.push(new bootstrap.Tooltip(tooltipTriggerEl));
                    });
                };

                onMounted(() => {
                    // This is a hack to provide non-component parts of the app with a reference to the app itself
                    window.getApp = () => ({
                        getImageByPath,
                    });
                });

                // Provide for child components
                Vue.provide('getApp', () => ({ getImageByPath }));


                return {
                    // State
                    isLoading,
                    directoryHandle,
                    album,
                    imageList,
                    currentSpreadIndex,
                    cropEditor,
                    // Computed
                    totalSpreads,
                    currentSpread,
                    isFirstPage,
                    isLastPage,
                    isSpreadDeletable,
                    canNavigatePrev,
                    canNavigateNext,
                    canMoveSpreadLeft,
                    canMoveSpreadRight,
                    pageNumberDisplay,
                    usedImagePaths,
                    // Methods
                    selectFolder,
                    navigateSpread,
                    addSpread,
                    deleteSpread,
                    moveSpread,
                    navigateToImagePage,
                    updatePage,
                    handleImageBankDragStart,
                    handleCellDragStart,
                    handleImageDrop,
                    openCropEditor,
                    saveCrop,
                };
            }
        });

        app.mount('#app');

    </script>
</body>
</html>