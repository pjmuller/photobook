<!-- works perfectly, yet the zoom is not 100% -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resizable Photo Album</title>

    <!-- Bootstrap 5 CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Custom Styles -->
    <style>
        body {
            background-color: #f0f2f5;
            font-family: sans-serif;
        }

        /* --- Album Layout & Aspect Ratio --- */
        #album-container {
            /* This div enforces the aspect ratio for the entire two-page spread.
               The ratio is (35+35):29 or 70:29.
               height = (29 / 70) * width.
               We use padding-bottom as a percentage of the width. */
            position: relative;
            width: 100%;
            padding-bottom: calc(100% * 29 / 70);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            background-color: #333;
        }

        #album-content {
            /* This positions the actual content inside the aspect-ratio container. */
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            gap: 10px; /* This creates the center spine/gutter of the album */
            padding: 10px;
        }

        .page {
            width: 50%;
            height: 100%;
            background-color: #fff;
            display: flex;
            flex-direction: column;
        }

        .row-split {
            /* These are the direct children of the split instance for rows */
            display: flex;
            flex-direction: row;
        }

        .cell {
            /* This is the final container for each image */
            position: relative;
            overflow: hidden;
            background-color: #e9ecef;
            user-select: none; /* Prevents text selection while dragging image */
        }
        
        /* --- Split.js Gutter Styling --- */
        .gutter {
            background-color: #fff;
            background-repeat: no-repeat;
            background-position: center;
        }

        .gutter.gutter-vertical {
            /* The horizontal line between rows */
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="10" height="30"><path d="M0,14.5 H10 M0,15.5 H10" stroke="%23888" stroke-width="1"/></svg>');
            cursor: row-resize;
            height: 10px;
        }

        .gutter.gutter-horizontal {
            /* The vertical line between cells */
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="30" height="10"><path d="M14.5,0 V10 M15.5,0 V10" stroke="%23888" stroke-width="1"/></svg>');
            cursor: col-resize;
            width: 10px;
        }
        
        /* --- Image Cropping UI --- */
        .cell img {
            position: absolute;
            left: 50%;
            top: 50%;
            transform-origin: center center;
            cursor: grab;
            max-width: none; /* Override bootstrap defaults */
        }

        .cell img.grabbing {
            cursor: grabbing;
        }

        .cell .controls-overlay {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            padding: 5px 10px;
            display: flex;
            align-items: center;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            pointer-events: none; /* Allows clicks to pass through to the image */
        }

        .cell:hover .controls-overlay {
            opacity: 1;
        }

        .cell .zoom-slider {
            width: 100%;
            margin: 0;
            pointer-events: auto; /* Re-enable pointer events for the slider itself */
        }

    </style>
</head>
<body>

    <main class="container-fluid my-4">
        <h1 class="text-center mb-4">Resizable Photo Album</h1>
        <div id="album-container">
            <div id="album-content">
                <!-- Left Page -->
                <div id="page-left" class="page">
                    <div class="row-split">
                        <div class="cell"></div>
                        <div class="cell"></div>
                        <div class="cell"></div>
                    </div>
                    <div class="row-split">
                        <div class="cell"></div>
                        <div class="cell"></div>
                        <div class="cell"></div>
                    </div>
                </div>
                <!-- Right Page -->
                <div id="page-right" class="page">
                    <div class="row-split">
                        <div class="cell"></div>
                        <div class="cell"></div>
                        <div class="cell"></div>
                    </div>
                    <div class="row-split">
                        <div class="cell"></div>
                        <div class="cell"></div>
                        <div class="cell"></div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Split.js CDN -->
    <script src="https://unpkg.com/split.js/dist/split.min.js"></script>

    <!-- Main Application Logic -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            /**
             * Creates and manages an interactive, pannable, zoomable image within a container cell.
             * @param {HTMLElement} cell The container element for the image.
             * @param {number} imageId A unique ID for the placeholder image.
             */
            function createImageCropper(cell, imageId) {
                const img = document.createElement('img');
                const controlsOverlay = document.createElement('div');
                const zoomSlider = document.createElement('input');

                controlsOverlay.className = 'controls-overlay';
                zoomSlider.type = 'range';
                zoomSlider.min = 0;
                zoomSlider.max = 100;
                zoomSlider.value = 0;
                zoomSlider.className = 'zoom-slider';
                
                controlsOverlay.appendChild(zoomSlider);
                cell.appendChild(img);
                cell.appendChild(controlsOverlay);

                let state = {
                    scale: 1,
                    minScale: 1,
                    maxScale: 4,
                    translateX: 0,
                    translateY: 0,
                    isDragging: false,
                    dragStartX: 0,
                    dragStartY: 0,
                };

                const updateTransform = () => {
                    img.style.transform = `translate(-50%, -50%) translate(${state.translateX}px, ${state.translateY}px) scale(${state.scale})`;
                };
                
                const clamp = (value, min, max) => Math.max(min, Math.min(value, max));

                const recalculateBoundsAndPosition = () => {
                    const cellRect = cell.getBoundingClientRect();
                    const imgNaturalWidth = img.naturalWidth || cellRect.width; // Fallback if image not loaded
                    const imgNaturalHeight = img.naturalHeight || cellRect.height;
                    
                    if (cellRect.width === 0 || cellRect.height === 0 || imgNaturalWidth === 0 || imgNaturalHeight === 0) {
                        return; // Avoid division by zero if element is hidden
                    }

                    // Calculate the minimum scale to "cover" the cell
                    state.minScale = Math.max(
                        cellRect.width / imgNaturalWidth,
                        cellRect.height / imgNaturalHeight
                    );

                    // If current scale is too small, reset it
                    if (state.scale < state.minScale) {
                        state.scale = state.minScale;
                        zoomSlider.value = 0;
                    }
                    
                    // Adjust slider to reflect current scale relative to new min/max
                    const percent = (state.scale - state.minScale) / (state.maxScale - state.minScale);
                    zoomSlider.value = clamp(percent * 100, 0, 100);

                    // Recalculate clamping bounds for panning
                    const currentImgWidth = imgNaturalWidth * state.scale;
                    const currentImgHeight = imgNaturalHeight * state.scale;

                    const xBound = Math.max(0, (currentImgWidth - cellRect.width) / 2);
                    const yBound = Math.max(0, (currentImgHeight - cellRect.height) / 2);

                    state.translateX = clamp(state.translateX, -xBound, xBound);
                    state.translateY = clamp(state.translateY, -yBound, yBound);

                    updateTransform();
                };

                img.onload = () => {
                    recalculateBoundsAndPosition();
                };
                // Set src after onload is defined
                img.src = `https://picsum.photos/seed/${imageId}/800/600`;
                

                // --- Event Listeners ---

                zoomSlider.addEventListener('input', (e) => {
                    const sliderValue = e.target.value / 100; // 0 to 1
                    state.scale = state.minScale + (state.maxScale - state.minScale) * sliderValue;
                    recalculateBoundsAndPosition(); // Recalculate bounds and clamp position
                });

                img.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    state.isDragging = true;
                    img.classList.add('grabbing');
                    state.dragStartX = e.clientX - state.translateX;
                    state.dragStartY = e.clientY - state.translateY;
                });

                window.addEventListener('mousemove', (e) => {
                    if (!state.isDragging) return;
                    e.preventDefault();
                    
                    const newTranslateX = e.clientX - state.dragStartX;
                    const newTranslateY = e.clientY - state.dragStartY;
                    
                    state.translateX = newTranslateX;
                    state.translateY = newTranslateY;
                    
                    // We don't clamp during move, but on release and resize for a smoother feel
                    recalculateBoundsAndPosition(); 
                });

                window.addEventListener('mouseup', (e) => {
                    if (state.isDragging) {
                        state.isDragging = false;
                        img.classList.remove('grabbing');
                        // Final clamp on mouse up
                        recalculateBoundsAndPosition(); 
                    }
                });

                // Return a public method to be called when cell is resized
                return { recalculateBoundsAndPosition };
            }

            // --- Main Initialization ---
            const allCells = document.querySelectorAll('.cell');
            const croppers = [];
            allCells.forEach((cell, index) => {
                const cropper = createImageCropper(cell, index + 1);
                croppers.push(cropper);
            });

            const onDragHandler = () => {
                // When any gutter is dragged, cell sizes change.
                // We need to tell every cropper to re-evaluate its bounds.
                croppers.forEach(cropper => cropper.recalculateBoundsAndPosition());
            };

            // Initialize Split.js for Pages -> Rows
            ['#page-left', '#page-right'].forEach(pageId => {
                const pageElement = document.querySelector(pageId);
                const rows = Array.from(pageElement.children).filter(el => el.classList.contains('row-split'));
                Split(rows, {
                    direction: 'vertical',
                    sizes: [50, 50],
                    minSize: 100,
                    gutterSize: 10,
                    onDrag: onDragHandler
                });
            });

            // Initialize Split.js for Rows -> Cells
            document.querySelectorAll('.row-split').forEach(rowElement => {
                const cells = Array.from(rowElement.children).filter(el => el.classList.contains('cell'));
                Split(cells, {
                    direction: 'horizontal',
                    sizes: [33.33, 33.33, 33.33],
                    minSize: 100,
                    gutterSize: 10,
                    onDrag: onDragHandler
                });
            });
            
            // Recalculate on window resize as well
            window.addEventListener('resize', onDragHandler);
        });
    </script>
</body>
</html>