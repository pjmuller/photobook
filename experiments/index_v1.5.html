<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Family Album Photobook Creator</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/croppie/2.6.5/croppie.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/croppie/2.6.5/croppie.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/exif-js@2.3.0/exif.js"></script>
    <style>
        :root {
            --page-width-cm: 35cm;
            --page-height-cm: 29cm;
            --margin-cm: 1cm;
            --gutter-cm: 0.5cm;
            --image-bank-height: 170px;
            --controls-height: 60px;
        }

        body {
            font-family: sans-serif;
            overflow: hidden; /* Prevent scrollbars from initial layout */
            margin: 0;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .main-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background-color: rgba(255,255,255,0.8);
            padding: 5px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .album-viewport {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Important for scaling */
            padding: 10px; /* Space around the scaled album */
            position: relative; /* For page numbers */
        }

        .album-container {
            display: flex;
            justify-content: center;
            align-items: center;
            transform-origin: center center; /* For scaling */
        }

        .page {
            width: var(--page-width-cm);
            height: var(--page-height-cm);
            background-color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Clip content to page boundaries */
        }
        
        .page-content-area {
            margin: var(--margin-cm);
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: var(--gutter-cm); /* This is for rows */
            position: relative; /* For gutters */
        }

        .page-row {
            display: flex;
            flex-grow: 1; /* Distribute height based on height_percent */
            gap: var(--gutter-cm); /* This is for columns */
        }

        .page-column {
            flex-grow: 1; /* Distribute width based on width_grid */
            border: 2px dashed #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px; /* Approx 0.5cm */
            color: #aaa;
            position: relative;
            overflow: hidden; /* Crucial for cropped image display */
        }
        .page-column.has-image {
            border-style: solid;
            border-color: #bbb;
        }

        .page-column img.cropped-image {
            position: absolute;
            /* width, height, transform set by JS */
        }
        
        .page-placeholder-text {
            pointer-events: none; /* Allow drop through text */
        }

        .single-page-container.right { margin-left: calc(var(--page-width-cm) / 2 + var(--gutter-cm) / 2); }
        .single-page-container.left { margin-right: calc(var(--page-width-cm) / 2 + var(--gutter-cm) / 2); }
        .spread-spacer { width: var(--gutter-cm); }

        .image-bank {
            height: var(--image-bank-height);
            background-color: #333;
            color: white;
            padding: 10px;
            display: flex;
            overflow-x: auto;
            overflow-y: hidden;
            gap: 10px;
            align-items: center; /* Vertically center thumbnails */
            flex-shrink: 0; /* Prevent shrinking */
        }

        .image-bank-thumb {
            height: 150px;
            width: auto;
            border: 2px solid transparent;
            cursor: grab;
            transition: transform 0.1s ease-out;
        }
        .image-bank-thumb:hover {
            transform: scale(1.1);
            border-color: #0d6efd;
        }
        .image-bank-thumb.used {
            opacity: 0.5;
            cursor: pointer;
        }
        .image-bank-thumb.used:hover {
            opacity: 0.7;
        }

        .page-number-display {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.5);
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
        }

        /* Layout change icon and menu */
        .layout-change-icon {
            position: absolute;
            top: 5px;
            font-size: 1.5rem; /* Approx 0.7cm */
            color: #0d6efd;
            cursor: pointer;
            z-index: 10;
        }
        .layout-change-icon.left-page { left: 5px; }
        .layout-change-icon.right-page { right: 5px; }
        .layout-change-icon.disabled { color: #ccc; cursor: not-allowed; }

        .layout-menu {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            padding: 5px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .layout-menu-item {
            padding: 5px;
            cursor: pointer;
            white-space: pre; /* For multi-line symbols */
            font-family: monospace;
            line-height: 1.2;
            text-align: center;
            border: 1px solid transparent;
        }
        .layout-menu-item:hover {
            background-color: #f0f0f0;
            border-color: #ccc;
        }

        /* Croppie Modal */
        .croppie-modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
        }
        .croppie-modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            max-width: 90vw;
            max-height: 90vh;
        }
        #croppie-container {
            width: 70vw; /* Adjust as needed */
            height: 70vh; /* Adjust as needed */
        }

        /* Gutters for resizing */
        .resize-gutter {
            position: absolute;
            background-color: transparent; /* Invisible */
            z-index: 5; /* Above page content, below layout menu */
        }
        .resize-gutter:hover {
            background-color: rgba(128, 128, 128, 0.3); /* Gray on hover */
        }
        .resize-gutter.row-gutter {
            width: 100%;
            height: var(--gutter-cm); /* Interaction height */
            cursor: row-resize;
        }
        .resize-gutter.col-gutter {
            height: 100%;
            width: var(--gutter-cm); /* Interaction width */
            cursor: col-resize;
        }
        
        /* Initial state button */
        .initial-state-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
        }

        [x-cloak] { display: none !important; }
    </style>
</head>
<body x-data="albumApp()" x-init="initApp()" x-cloak>

    <div class="main-controls btn-group" role="group" aria-label="Main Controls" x-show="appState === 'albumLoaded'">
        <button type="button" class="btn btn-light" @click="prevView()" :disabled="!canGoPrev()" title="Previous Page(s)">
            <i class="bi bi-arrow-left"></i>
        </button>
        <button type="button" class="btn btn-light" @click="nextView()" :disabled="!canGoNext()" title="Next Page(s)">
            <i class="bi bi-arrow-right"></i>
        </button>

        <button type="button" class="btn btn-light" @click="addSpread()" :disabled="!canAddSpread()" title="Add Double-Page Spread">
            <i class="bi bi-plus-lg"></i>
        </button>
        
        <div class="btn-group" role="group">
            <button id="btnGroupDrop1" type="button" class="btn btn-light dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false" :disabled="!canMoveOrDeleteSpread()" title="Move/Delete Spread">
                <i class="bi bi-arrow-left-right"></i>
            </button>
            <ul class="dropdown-menu" aria-labelledby="btnGroupDrop1">
                <li><a class="dropdown-item" href="#" @click.prevent="moveSpread('left')" :class="{ 'disabled': !canMoveSpreadLeft() }">Move Spread Left <i class="bi bi-arrow-bar-left"></i></a></li>
                <li><a class="dropdown-item" href="#" @click.prevent="moveSpread('right')" :class="{ 'disabled': !canMoveSpreadRight() }">Move Spread Right <i class="bi bi-arrow-bar-right"></i></a></li>
                <li><hr class="dropdown-divider"></li>
                <li><a class="dropdown-item" href="#" @click.prevent="deleteSpread()" :class="{ 'disabled': !canMoveOrDeleteSpread() }">Delete Spread <i class="bi bi-trash"></i></a></li>
            </ul>
        </div>
    </div>

    <div class="album-viewport" 
        x-ref="albumViewport"
        @dragover.prevent 
        @drop.prevent="handleDropOnGrayArea($event)">

        <div class="initial-state-container" x-show="appState === 'initial'">
            <button class="btn btn-primary btn-lg" @click="selectFolder()">Select Image Folder</button>
        </div>
        <div class="initial-state-container" x-show="appState === 'loading'">
            <p>Loading album...</p>
        </div>
        <div class="initial-state-container" x-show="appState === 'error'">
            <p x-text="errorMessage"></p>
            <button class="btn btn-primary ms-3" @click="appState = 'initial'; errorMessage = '';">Try Again</button>
        </div>

        <div class="album-container" x-show="appState === 'albumLoaded' && currentDisplayInfo.type !== 'NO_PAGES'" x-ref="albumContainer"
             :style="{ transform: `scale(${albumScale})` }">
            
            <!-- Single Left Page -->
            <template x-if="currentDisplayInfo.type === 'SINGLE_LEFT'">
                <div class="page-container single-page-container left">
                    <div x-html="renderPage(currentDisplayInfo.pageObject, currentDisplayInfo.pageIndexInAlbum)"></div>
                </div>
            </template>

            <!-- Single Right Page -->
            <template x-if="currentDisplayInfo.type === 'SINGLE_RIGHT'">
                <div class="page-container single-page-container right">
                    <div x-html="renderPage(currentDisplayInfo.pageObject, currentDisplayInfo.pageIndexInAlbum)"></div>
                </div>
            </template>

            <!-- Spread -->
            <template x-if="currentDisplayInfo.type === 'SPREAD'">
                <div class="d-flex align-items-center">
                    <div class="page-container"> <!-- Left Page of Spread -->
                        <div x-html="renderPage(currentDisplayInfo.leftPageObject, currentDisplayInfo.leftPageIndexInAlbum)"></div>
                    </div>
                    <div class="spread-spacer"></div>
                    <div class="page-container"> <!-- Right Page of Spread -->
                        <div x-html="renderPage(currentDisplayInfo.rightPageObject, currentDisplayInfo.rightPageIndexInAlbum)"></div>
                    </div>
                </div>
            </template>
        </div>
        <div class="page-number-display" x-show="appState === 'albumLoaded' && currentDisplayInfo.type !== 'NO_PAGES'" x-text="getPageNumberText()"></div>
    </div>

    <div class="image-bank" x-show="appState === 'albumLoaded'">
        <template x-for="image in sortedImagesInFolder" :key="image.path">
            <img :src="image.dataUrl" 
                 :alt="image.name"
                 class="image-bank-thumb"
                 :class="{ 'used': image.used }"
                 :draggable="!image.used"
                 @dragstart="handleDragStartFromBank($event, image)"
                 @click="image.used ? navigateToImagePage(image) : null"
                 :title="image.used ? `Used on page containing image ${image.path}` : image.name">
        </template>
    </div>

    <!-- Layout Change Menu -->
    <div class="layout-menu" x-show="showLayoutMenu" 
         :style="layoutMenuPosition"
         @click.outside="showLayoutMenu = false">
        <template x-for="layoutKey in Object.keys(PREDEFINED_LAYOUTS)" :key="layoutKey">
            <div class="layout-menu-item" 
                 @click="applyLayoutChange(layoutMenuTarget.pageIndex, layoutKey)"
                 x-html="PREDEFINED_LAYOUTS[layoutKey].symbol.replace(/\n/g, '<br>')">
            </div>
        </template>
    </div>

    <!-- Croppie Modal -->
    <div class="croppie-modal" x-show="showCropModal" @click.self="cancelCrop()">
        <div class="croppie-modal-content">
            <div id="croppie-container"></div>
            <div class="mt-3 text-center">
                <button class="btn btn-secondary me-2" @click="cancelCrop()">Cancel</button>
                <button class="btn btn-primary" @click="saveCrop()">Save Crop</button>
            </div>
        </div>
    </div>

    <script>
    const PHOTOBOOK_VERSION = "0.1";
    const PREDEFINED_LAYOUTS = {
        '1': {
            name: '1',
            symbol: '██',
            rows: [{ height_percent: 100, columns: [{ width_grid: 12 }] }]
        },
        '2-2': {
            name: '2-2',
            symbol: '██▌██▌\n██▌██▌',
            rows: [
                { height_percent: 50, columns: [{ width_grid: 6 }, { width_grid: 6 }] },
                { height_percent: 50, columns: [{ width_grid: 6 }, { width_grid: 6 }] }
            ]
        },
        '2-3': {
            name: '2-3',
            symbol: '██▌██▌\n█▌█▌█▌',
            rows: [
                { height_percent: 50, columns: [{ width_grid: 4 }, { width_grid: 8 }] },
                { height_percent: 50, columns: [{ width_grid: 4 }, { width_grid: 4 }, { width_grid: 4 }] }
            ]
        },
        '3-2': {
            name: '3-2',
            symbol: '█▌█▌█▌\n██▌██▌',
            rows: [
                { height_percent: 50, columns: [{ width_grid: 4 }, { width_grid: 4 }, { width_grid: 4 }] },
                { height_percent: 50, columns: [{ width_grid: 6 }, { width_grid: 6 }] }
            ]
        }
    };

    function albumApp() {
        return {
            appState: 'initial', // 'initial', 'loading', 'albumLoaded', 'error'
            errorMessage: '',
            directoryHandle: null,
            imagesInFolder: [], // { path: string, name: string, dataUrl?: string, exifDate?: Date, used: boolean, pageId?: string, rowIndex?: number, colIndex?: number }
            album: {
                photobook_version: PHOTOBOOK_VERSION,
                pages: []
            },
            currentViewIndex: 0, // Index for the current view (SR, Spread, SL)
            
            albumScale: 1,
            PAGE_WIDTH_CM: 35,
            PAGE_HEIGHT_CM: 29,
            MARGIN_CM: 1,
            GUTTER_CM: 0.5,
            PREDEFINED_LAYOUTS: PREDEFINED_LAYOUTS, // Make it accessible in template

            showLayoutMenu: false,
            layoutMenuTarget: { pageIndex: null, side: 'left' }, // side: 'left' or 'right' for positioning
            layoutMenuPosition: { top: '0px', left: '0px' },

            showCropModal: false,
            croppingContext: { pageId: null, rowIndex: null, colIndex: null, path: null, currentCrop: null, imageElement: null, cellAspectRatio: 1 },
            croppieInstance: null,

            isResizing: false,
            resizeContext: { type: null, pageElement: null, pageIndex: null, rowIndex: null, colIndex: null, gutterElement: null, startX: 0, startY: 0, initialSizes: [] },

            initApp() {
                // Bootstrap dropdowns
                var dropdownElementList = [].slice.call(document.querySelectorAll('.dropdown-toggle'))
                var dropdownList = dropdownElementList.map(function (dropdownToggleEl) {
                    return new bootstrap.Dropdown(dropdownToggleEl)
                });
                
                this.$watch('album.pages', () => this.saveAlbumData(), { deep: true });
                this.$watch('currentViewIndex', () => this.updateAlbumScale()); // Recalculate scale if view type changes (single/spread)
                
                window.addEventListener('resize', () => this.updateAlbumScale());

                // Prevent default for F5, Ctrl+R to avoid issues with file handles
                // This is aggressive, might remove if not strictly needed or causing UX issues
                // window.addEventListener('keydown', function(e) {
                //     if ((e.key === 'r' && (e.ctrlKey || e.metaKey)) || e.key === 'F5') {
                //         e.preventDefault();
                //         console.warn("Page refresh disabled to preserve directory handle.");
                //     }
                // });
            },

            // --- Folder and Album Loading ---
            async selectFolder() {
                try {
                    this.appState = 'loading';
                    this.directoryHandle = await window.showDirectoryPicker();
                    await this.loadImagesFromFolder();
                    if (this.imagesInFolder.length === 0) {
                        this.errorMessage = "No JPG files found in the selected folder. Please select another folder.";
                        this.appState = 'error';
                        this.directoryHandle = null;
                        return;
                    }
                    await this.loadOrCreateAlbum();
                    this.appState = 'albumLoaded';
                    this.currentViewIndex = 0; // Start at the first view
                    this.$nextTick(() => this.updateAlbumScale());
                } catch (err) {
                    console.error("Error selecting folder or loading album:", err);
                    this.errorMessage = `Error: ${err.message}. Try selecting the folder again.`;
                    this.appState = 'error';
                    this.directoryHandle = null;
                }
            },

            async loadImagesFromFolder() {
                this.imagesInFolder = [];
                const imagePromises = [];
                for await (const entry of this.directoryHandle.values()) {
                    if (entry.kind === 'file' && (entry.name.toLowerCase().endsWith('.jpg') || entry.name.toLowerCase().endsWith('.jpeg'))) {
                        imagePromises.push(this.processImageFile(entry));
                    }
                }
                await Promise.all(imagePromises);
                // Sort images (EXIF date then filename)
                this.imagesInFolder.sort((a, b) => {
                    if (a.exifDate && b.exifDate) return a.exifDate - b.exifDate;
                    if (a.exifDate) return -1;
                    if (b.exifDate) return 1;
                    return a.name.localeCompare(b.name);
                });
            },

            async processImageFile(fileHandle) {
                const file = await fileHandle.getFile();
                const dataUrl = await this.readFileAsDataURL(file);
                const imageInfo = {
                    path: file.name, // Store relative path (name)
                    name: file.name,
                    dataUrl: dataUrl,
                    used: false,
                    exifDate: null
                };

                // EXIF data extraction
                try {
                    const exifData = await new Promise((resolve, reject) => {
                        EXIF.getData(file, function() { // `file` object, not img element yet
                            try {
                                const dateTimeOriginal = EXIF.getTag(this, "DateTimeOriginal");
                                if (dateTimeOriginal) {
                                    // Format: "YYYY:MM:DD HH:MM:SS"
                                    const parts = dateTimeOriginal.split(" ");
                                    const dateParts = parts[0].split(":");
                                    const timeParts = parts[1].split(":");
                                    resolve(new Date(dateParts[0], dateParts[1] - 1, dateParts[2], timeParts[0], timeParts[1], timeParts[2]));
                                } else {
                                    resolve(null);
                                }
                            } catch (exifError) {
                                console.warn("EXIF error for", file.name, exifError);
                                resolve(null); // Resolve with null if EXIF parsing fails for a tag
                            }
                        });
                    });
                    imageInfo.exifDate = exifData;
                } catch (err) {
                    console.warn(`Could not read EXIF data for ${file.name}:`, err);
                }
                this.imagesInFolder.push(imageInfo);
            },

            readFileAsDataURL(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            },

            async loadOrCreateAlbum() {
                try {
                    const fileHandle = await this.directoryHandle.getFileHandle('album.json', { create: false });
                    const file = await fileHandle.getFile();
                    const content = await file.text();
                    const loadedAlbum = JSON.parse(content);

                    if (loadedAlbum.photobook_version !== PHOTOBOOK_VERSION) {
                        this.errorMessage = `Incompatible album.json version. Expected ${PHOTOBOOK_VERSION}, found ${loadedAlbum.photobook_version}. Please remove album.json and reload.`;
                        this.appState = 'error';
                        throw new Error(this.errorMessage);
                    }
                    this.album = loadedAlbum;
                    this.updateImageBankStatusFromAlbum();

                } catch (err) { // If file not found or other error
                    if (err.name === 'NotFoundError' || this.appState !== 'error') { // if not version error
                        console.log("album.json not found or error loading, creating default album.");
                        this.createDefaultAlbum();
                        await this.saveAlbumData();
                    } else {
                        throw err; // rethrow version error
                    }
                }
            },

            createDefaultAlbum() {
                this.album = {
                    photobook_version: PHOTOBOOK_VERSION,
                    pages: [
                        this.createPage("1", crypto.randomUUID()), // Page 0 (First Page)
                        this.createPage("2-3", crypto.randomUUID()), // Page 1
                        this.createPage("3-2", crypto.randomUUID()), // Page 2
                        this.createPage("1", crypto.randomUUID())  // Page 3 (Last Page)
                    ]
                };
                this.updateImageBankStatusFromAlbum();
            },

            createPage(layoutKey, id = null) {
                const layout = PREDEFINED_LAYOUTS[layoutKey];
                if (!layout) {
                    console.error("Unknown layout key:", layoutKey);
                    return null; // Or throw error
                }
                return {
                    id: id || crypto.randomUUID(),
                    layout: layoutKey,
                    rows: JSON.parse(JSON.stringify(layout.rows)) // Deep copy
                };
            },

            async saveAlbumData() {
                if (!this.directoryHandle || this.appState !== 'albumLoaded') return;
                try {
                    const fileHandle = await this.directoryHandle.getFileHandle('album.json', { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(JSON.stringify(this.album, null, 2));
                    await writable.close();
                    console.log("Album saved.");
                } catch (err) {
                    console.error("Error saving album.json:", err);
                    this.errorMessage = "Error saving album: " + err.message;
                    // Potentially set appState to 'error' or show a non-blocking notification
                }
            },

            updateImageBankStatusFromAlbum() {
                const usedPaths = new Set();
                this.album.pages.forEach(page => {
                    page.rows.forEach(row => {
                        row.columns.forEach(col => {
                            if (col.path) {
                                usedPaths.add(col.path);
                            }
                        });
                    });
                });
                this.imagesInFolder.forEach(img => {
                    img.used = usedPaths.has(img.path);
                    if (!img.used) {
                        delete img.pageId;
                        delete img.rowIndex;
                        delete img.colIndex;
                    } else {
                        // This part is tricky, as an image path could be on multiple pages if not handled properly
                        // For simplicity, we'll just mark as used. Navigation to page is harder.
                        // To implement navigateToImagePage, we'd need to store where it's used.
                        // For now, just marking as used.
                    }
                });
            },
            
            get sortedImagesInFolder() {
                // Already sorted during loadImagesFromFolder
                return this.imagesInFolder;
            },

            // --- Page Rendering & Display Logic ---
            renderPage(page, pageIndexInAlbum) {
                if (!page) return '<div class="page">Error: Page data missing</div>';
                
                let pageHtml = `<div class="page" data-page-id="${page.id}" data-page-index-in-album="${pageIndexInAlbum}">`;
                
                // Layout change icon
                const isFirstPage = pageIndexInAlbum === 0;
                const isLastPage = pageIndexInAlbum === (this.album.pages.length - 1);
                const layoutChangeDisabled = (isFirstPage || isLastPage) && page.layout === '1';

                let iconPositionClass = '';
                // Determine if this page is currently displayed on left or right
                const displayInfo = this.currentDisplayInfo;
                let iconSide = '';
                if (displayInfo.type === 'SINGLE_RIGHT' && displayInfo.pageObject.id === page.id) iconSide = 'right';
                else if (displayInfo.type === 'SINGLE_LEFT' && displayInfo.pageObject.id === page.id) iconSide = 'left';
                else if (displayInfo.type === 'SPREAD') {
                    if (displayInfo.leftPageObject.id === page.id) iconSide = 'left';
                    else if (displayInfo.rightPageObject.id === page.id) iconSide = 'right';
                }
                
                if (iconSide === 'left') iconPositionClass = 'left-page';
                else if (iconSide === 'right') iconPositionClass = 'right-page';

                if (iconPositionClass) { // Only add icon if page is clearly left/right in current view
                    pageHtml += `<i class="bi bi-grid-fill layout-change-icon ${iconPositionClass} ${layoutChangeDisabled ? 'disabled' : ''}" 
                                @click="${layoutChangeDisabled ? '' : `toggleLayoutMenu(${pageIndexInAlbum}, $event)`}"></i>`;
                }

                pageHtml += `<div class="page-content-area" x-ref="pageContentArea_${page.id}">`;

                page.rows.forEach((row, rowIndex) => {
                    pageHtml += `<div class="page-row" style="flex-basis: ${row.height_percent}%" data-row-index="${rowIndex}">`;
                    row.columns.forEach((col, colIndex) => {
                        const totalGridUnitsInRow = row.columns.reduce((sum, c) => sum + c.width_grid, 0);
                        const colWidthPercent = (col.width_grid / totalGridUnitsInRow) * 100;
                        
                        pageHtml += `<div class="page-column ${col.path ? 'has-image' : ''}" 
                                          style="flex-basis: ${colWidthPercent}%"
                                          data-col-index="${colIndex}"
                                          @dragover.prevent="handleDragOverCell($event)"
                                          @dragleave.prevent="handleDragLeaveCell($event)"
                                          @drop.prevent="handleDropOnCell($event, '${page.id}', ${rowIndex}, ${colIndex})"
                                          @dblclick="${col.path ? `openCropModal('${page.id}', ${rowIndex}, ${colIndex})` : ''}"
                                          draggable="${col.path ? 'true' : 'false'}"
                                          @dragstart="${col.path ? `handleDragStartFromCell($event, '${page.id}', ${rowIndex}, ${colIndex})` : ''}">`;
                        if (col.path) {
                            const imageInBank = this.imagesInFolder.find(img => img.path === col.path);
                            if (imageInBank && imageInBank.dataUrl) {
                                const cropStyle = this.getCropStyle(imageInBank.dataUrl, col, `pageContentArea_${page.id}`, rowIndex, colIndex);
                                pageHtml += `<img src="${imageInBank.dataUrl}" class="cropped-image" style="${cropStyle}" alt="Cropped image ${col.path}">`;
                            } else {
                                pageHtml += `<span class="page-placeholder-text">Image not found: ${col.path}</span>`;
                            }
                        } else {
                            pageHtml += '<span class="page-placeholder-text">Drop image</span>';
                        }
                        pageHtml += `</div>`;

                        // Add column resize gutter (if not the last column)
                        if (colIndex < row.columns.length - 1) {
                            pageHtml += `<div class="resize-gutter col-gutter"
                                             style="left: calc(${row.columns.slice(0, colIndex + 1).reduce((sum, c, idx) => sum + (c.width_grid / totalGridUnitsInRow * 100) + (idx < colIndex ? (this.GUTTER_CM_AS_PERCENT_OF_ROW_WIDTH) : 0) , 0)}% - ${this.GUTTER_CM/2}px);" 
                                             @mousedown.prevent="startResize($event, 'column', '${page.id}', ${rowIndex}, ${colIndex})"></div>`;
                        }
                    });
                    pageHtml += `</div>`;

                    // Add row resize gutter (if not the last row)
                    if (rowIndex < page.rows.length - 1) {
                         pageHtml += `<div class="resize-gutter row-gutter"
                                          style="top: calc(${page.rows.slice(0, rowIndex + 1).reduce((sum, r, idx) => sum + r.height_percent + (idx < rowIndex ? (this.GUTTER_CM_AS_PERCENT_OF_PAGE_HEIGHT) : 0), 0)}% - ${this.GUTTER_CM/2}px);"
                                          @mousedown.prevent="startResize($event, 'row', '${page.id}', ${rowIndex})"></div>`;
                    }
                });

                pageHtml += `</div></div>`; // Close page-content-area and page
                return pageHtml;
            },

            get GUTTER_CM_AS_PERCENT_OF_ROW_WIDTH() {
                // This is an approximation as gutter is fixed cm, row width is percentage.
                // For simplicity, assuming average row width. This is mainly for gutter placement.
                // A more accurate calculation would need the rendered pixel width of the row.
                // This is complex because the page itself is scaled.
                // For now, let's use a small fixed pixel value for offset calculation in style,
                // or accept that gutter placement might be slightly off visually if using percentages.
                // The actual gutter elements are positioned based on percentages of their containers.
                // The visual gap is created by `gap` in flexbox.
                // The interactive gutter needs to be placed over this gap.
                // Let's assume the gutter's CSS width/height in CM is sufficient for interaction.
                // The style offset here is to center it.
                // The `left` for col-gutter and `top` for row-gutter needs to be calculated carefully.
                // For col-gutter: sum of widths of preceding columns + sum of preceding gutters.
                // For row-gutter: sum of heights of preceding rows + sum of preceding gutters.
                // The `this.GUTTER_CM / this.PAGE_WIDTH_CM * 100` or `this.GUTTER_CM / this.PAGE_HEIGHT_CM * 100`
                // might be useful for percentage calculations.
                // The current implementation in renderPage for gutter positioning is a rough estimate.
                // It should be: `calc(SUM_OF_PRECEDING_WIDTH_PERCENTS + NUM_PRECEDING_GUTTERS * GUTTER_WIDTH_PERCENT - (GUTTER_WIDTH_PERCENT / 2))`
                // This is getting too complex for inline style string generation.
                // A better way would be to absolutely position gutters using JS after render if precision is critical.
                // For now, the current approach is a simplification.
                return (this.GUTTER_CM / (this.PAGE_WIDTH_CM - 2 * this.MARGIN_CM)) * 100;
            },
            get GUTTER_CM_AS_PERCENT_OF_PAGE_HEIGHT() {
                return (this.GUTTER_CM / (this.PAGE_HEIGHT_CM - 2 * this.MARGIN_CM)) * 100;
            },


            getCropStyle(imageUrl, columnData, pageContentAreaRefKey, rowIndex, colIndex) {
                // This function needs access to the actual rendered dimensions of the cell
                // to calculate the correct scale and translate values.
                // This is difficult to do synchronously during the renderPage HTML string generation.
                // A better approach is to apply styles after render using $refs, or use CSS object-fit
                // for initial display and only apply precise transform after manual crop.
                // For now, let's assume auto-crop (center crop to fill).
                // The spec wants CSS transform.
                
                if (!columnData.crop || !columnData.crop.width) { // Auto-center-crop
                    // This is a simplified auto-crop (like object-fit: cover)
                    // It doesn't store crop coords, just displays. For true auto-crop to be saved,
                    // we'd need image dimensions.
                    return `object-fit: cover; width: 100%; height: 100%;`;
                }

                const { x, y, width, height } = columnData.crop;
                // We need original image dimensions to calculate this properly.
                // This is a placeholder. A full implementation would load the image, get naturalWidth/Height.
                // For now, assuming the crop data is relative to the original image and we want to scale
                // the cropped part to fill the cell.
                
                // Let's find the image element to get its natural dimensions
                const img = new Image();
                img.src = imageUrl; // This is async, so naturalWidth/Height might not be available immediately.
                                    // This is a fundamental issue with generating this style string directly.
                
                // Fallback if natural dimensions not available yet (e.g. during initial render string generation)
                // This will likely not be perfectly accurate until image is loaded.
                const naturalWidth = img.naturalWidth || 1600; // Placeholder
                const naturalHeight = img.naturalHeight || 1200; // Placeholder

                // Scale factor to make the cropped area (width, height) fit the cell.
                // The cell's aspect ratio is determined by its flex-basis and the row's height.
                // This is complex. For now, let's assume the Croppie step ensures aspect ratio match.
                // If cell dimensions are C_w, C_h, and crop dimensions I_w, I_h:
                // scale = C_w / I_w (should be same as C_h / I_h if aspect ratios match)
                // We don't know C_w, C_h here directly in pixels.
                // The image should be scaled such that its cropped width `width` becomes 100% of cell width.
                const scaleFactor = 1 / (width / naturalWidth); // Scale the image so that its original width becomes cellWidth / (cropWidth/originalWidth)
                                                                // i.e. img_display_width = naturalWidth * scaleFactor.
                                                                // We want crop_width_on_img * scaleFactor = cell_width
                                                                // So scaleFactor = cell_width / crop_width_on_img
                                                                // This means we need cell_width.
                // This is the CSS transform method:
                // Scale the image so the cropped width fills the cell's width.
                // `img_scale = cell_width / crop_details.width`
                // `img_width_attr = original_img_width * img_scale`
                // `img_height_attr = original_img_height * img_scale`
                // `translateX = -crop_details.x * img_scale`
                // `translateY = -crop_details.y * img_scale`
                // Since we don't know cell_width here, this is hard.
                // A simpler CSS approach if aspect ratios are locked by Croppie:
                const displayWidthPercent = (naturalWidth / width) * 100;
                const displayHeightPercent = (naturalHeight / height) * 100;
                const offsetXPercent = (x / width) * -100;
                const offsetYPercent = (y / height) * -100;

                return `width: ${displayWidthPercent}%; height: ${displayHeightPercent}%; transform: translate(${offsetXPercent}%, ${offsetYPercent}%);`;
            },

            updateAlbumScale() {
                this.$nextTick(() => {
                    if (!this.$refs.albumViewport || !this.$refs.albumContainer || this.appState !== 'albumLoaded' || this.album.pages.length === 0) {
                        this.albumScale = 1;
                        return;
                    }

                    const viewportWidth = this.$refs.albumViewport.clientWidth - 20; // 20px padding
                    const viewportHeight = this.$refs.albumViewport.clientHeight - 20; // 20px padding

                    let albumNaturalWidthPx, albumNaturalHeightPx;
                    
                    // Create a temporary page to measure CM to PX conversion
                    const tempPage = document.createElement('div');
                    tempPage.style.width = this.PAGE_WIDTH_CM + 'cm';
                    tempPage.style.height = this.PAGE_HEIGHT_CM + 'cm';
                    tempPage.style.position = 'absolute';
                    tempPage.style.visibility = 'hidden';
                    document.body.appendChild(tempPage);
                    const pageRenderedWidthPx = tempPage.offsetWidth;
                    const pageRenderedHeightPx = tempPage.offsetHeight;
                    const gutterRenderedWidthPx = (this.GUTTER_CM / this.PAGE_WIDTH_CM) * pageRenderedWidthPx; // Approx
                    document.body.removeChild(tempPage);

                    if (this.currentDisplayInfo.type === 'SINGLE_LEFT' || this.currentDisplayInfo.type === 'SINGLE_RIGHT') {
                        albumNaturalWidthPx = pageRenderedWidthPx;
                    } else if (this.currentDisplayInfo.type === 'SPREAD') {
                        albumNaturalWidthPx = 2 * pageRenderedWidthPx + gutterRenderedWidthPx;
                    } else { // NO_PAGES or error
                        this.albumScale = 1;
                        return;
                    }
                    albumNaturalHeightPx = pageRenderedHeightPx;

                    if (albumNaturalWidthPx === 0 || albumNaturalHeightPx === 0) {
                        this.albumScale = 1; return;
                    }
                    
                    const scaleX = viewportWidth / albumNaturalWidthPx;
                    const scaleY = viewportHeight / albumNaturalHeightPx;
                    this.albumScale = Math.min(scaleX, scaleY, 1); // Cap at 1 (no upscale)
                });
            },

            get currentDisplayInfo() {
                const pages = this.album.pages;
                const N = pages.length;
                const viewIdx = this.currentViewIndex;

                if (N === 0) return { type: 'NO_PAGES' };

                if (viewIdx === 0) { // First view is always page 0
                    return { type: 'SINGLE_RIGHT', pageObject: pages[0], pageIndexInAlbum: 0, pageNumber: 1 };
                }

                // Subsequent views
                // Each view after the first one conceptually tries to take two pages
                const firstPageInThisViewLogic = 1 + (viewIdx - 1) * 2;

                if (firstPageInThisViewLogic >= N) {
                    console.error("View index out of bounds", viewIdx, N);
                    return { type: 'ERROR_BOUNDS' };
                }

                // Check if this is the last page and it's single left
                // This happens if N is even, and this is the last page (index N-1)
                if (N > 1 && N % 2 === 0 && firstPageInThisViewLogic === N - 1) {
                    return { type: 'SINGLE_LEFT', pageObject: pages[N - 1], pageIndexInAlbum: N - 1, pageNumber: N };
                }

                // Otherwise, it's a spread
                const leftPageIndex = firstPageInThisViewLogic;
                const rightPageIndex = firstPageInThisViewLogic + 1;

                if (rightPageIndex >= N) {
                    // This means N is odd, and the last page is the right part of this spread
                    return { 
                        type: 'SPREAD', 
                        leftPageObject: pages[leftPageIndex], 
                        leftPageIndexInAlbum: leftPageIndex,
                        rightPageObject: pages[rightPageIndex], // This will be undefined if rightPageIndex === N
                                                                // but this path should only be hit if rightPageIndex < N
                        rightPageIndexInAlbum: rightPageIndex,
                        pageNumberStart: leftPageIndex + 1, 
                        pageNumberEnd: rightPageIndex + 1 
                    };
                }
                
                // Standard spread
                return { 
                    type: 'SPREAD', 
                    leftPageObject: pages[leftPageIndex], 
                    leftPageIndexInAlbum: leftPageIndex,
                    rightPageObject: pages[rightPageIndex], 
                    rightPageIndexInAlbum: rightPageIndex,
                    pageNumberStart: leftPageIndex + 1, 
                    pageNumberEnd: rightPageIndex + 1 
                };
            },

            get maxViewIndex() {
                const N = this.album.pages.length;
                if (N === 0) return -1; // No views
                if (N === 1) return 0;  // View 0: Page 0 (SR)
                // For N > 1:
                // View 0 is Page 0 (SR).
                // Remaining N-1 pages are handled by subsequent views.
                // Each subsequent view handles up to 2 pages.
                // Number of subsequent views = Math.ceil((N-1) / 2)
                // Total views = 1 (for page 0) + Math.ceil((N-1) / 2)
                // Max index = Total views - 1
                return Math.ceil((N - 1) / 2);
            },

            getPageNumberText() {
                const display = this.currentDisplayInfo;
                const N = this.album.pages.length;
                if (!display || display.type === 'NO_PAGES' || display.type === 'ERROR_BOUNDS') return "";

                if (display.type === 'SINGLE_RIGHT') return `Page ${display.pageNumber} / ${N}`;
                if (display.type === 'SINGLE_LEFT') return `Page ${display.pageNumber} / ${N}`;
                if (display.type === 'SPREAD') return `Pages ${display.pageNumberStart}-${display.pageNumberEnd} / ${N}`;
                return "";
            },

            // --- Navigation ---
            canGoPrev() { return this.currentViewIndex > 0; },
            canGoNext() { return this.currentViewIndex < this.maxViewIndex; },
            prevView() { if (this.canGoPrev()) this.currentViewIndex--; },
            nextView() { if (this.canGoNext()) this.currentViewIndex++; },

            navigateToImagePage(image) { // Basic navigation to the view containing the image
                if (!image.used || !this.album || !this.album.pages) return;
            
                let targetPageIndex = -1;
                for (let i = 0; i < this.album.pages.length; i++) {
                    const page = this.album.pages[i];
                    for (const row of page.rows) {
                        for (const col of row.columns) {
                            if (col.path === image.path) {
                                targetPageIndex = i;
                                break;
                            }
                        }
                        if (targetPageIndex !== -1) break;
                    }
                    if (targetPageIndex !== -1) break;
                }

                if (targetPageIndex === -1) return;

                // Find view index for this page index
                if (targetPageIndex === 0) {
                    this.currentViewIndex = 0;
                    return;
                }
                // For pages 1 onwards...
                // Each view (after view 0) covers 2 pages.
                // (targetPageIndex - 1) is the 0-based index into the "remaining pages" (pages[1]...)
                // Math.floor((targetPageIndex - 1) / 2) gives the 0-based index of the SPREAD view.
                // Add 1 because view 0 is the first page.
                this.currentViewIndex = 1 + Math.floor((targetPageIndex - 1) / 2);
            },

            // --- Page Actions (Add, Move, Delete) ---
            canAddSpread() {
                // Cannot add if viewing the last page AND the last page is single-left.
                // Or, more simply, you can always add. It inserts before the "last single page" if applicable.
                const N = this.album.pages.length;
                if (N === 0) return true; // Can add to empty album (will become P0, NewL, NewR, PLast)

                const display = this.currentDisplayInfo;
                // Disabled if viewing the last page (single left)
                // The spec says "Disabled button if viewing the last page."
                // This means if currentViewIndex is maxViewIndex AND the view is single-left.
                if (this.currentViewIndex === this.maxViewIndex) {
                    if (display.type === 'SINGLE_LEFT') return false;
                    if (display.type === 'SINGLE_RIGHT' && N === 1) return true; // Can add after first page if it's also last
                }
                return true;
            },

            addSpread() {
                if (!this.canAddSpread()) return;

                const newPageL = this.createPage("2-2"); // Default for new spread
                const newPageR = this.createPage("2-2");

                const N = this.album.pages.length;
                let insertAtIndex;

                if (N === 0) { // Special case: creating first album pages
                    this.album.pages.push(this.createPage("1")); // First page
                    this.album.pages.push(newPageL);
                    this.album.pages.push(newPageR);
                    this.album.pages.push(this.createPage("1")); // Last page
                    this.currentViewIndex = 1; // View the new spread
                    return;
                }
                
                const display = this.currentDisplayInfo;
                if (display.type === 'SINGLE_RIGHT') { // Viewing P0
                    insertAtIndex = 1; // Insert after P0
                } else if (display.type === 'SPREAD') {
                    insertAtIndex = display.rightPageIndexInAlbum + 1;
                } else if (display.type === 'SINGLE_LEFT') { // Viewing last page (SL)
                    insertAtIndex = display.pageIndexInAlbum; // Insert before this single left page
                } else {
                    console.error("Cannot determine insertion point for new spread.");
                    return;
                }

                this.album.pages.splice(insertAtIndex, 0, newPageL, newPageR);
                
                // Ensure last page is layout "1" if it's not the one just added
                if (this.album.pages.length > 0) {
                    const lastP = this.album.pages[this.album.pages.length - 1];
                    if (lastP.layout !== "1") lastP.layout = "1"; // Force last page to layout "1"
                }


                // Navigate to the new spread
                // If inserted at index `idx`, new left page is `pages[idx]`.
                // If `idx` is 0 (not possible here as P0 is always SR), view is 0.
                // Otherwise, view is `1 + Math.floor((idx - 1) / 2)`.
                this.currentViewIndex = 1 + Math.floor((insertAtIndex - 1) / 2);
                this.updateImageBankStatusFromAlbum(); // In case default layouts had images (they don't)
            },

            canMoveOrDeleteSpread() {
                const display = this.currentDisplayInfo;
                return display.type === 'SPREAD';
            },
            
            canMoveSpreadLeft() {
                if (!this.canMoveOrDeleteSpread()) return false;
                const display = this.currentDisplayInfo;
                // Cannot move left if it's the first spread (i.e., left page is album.pages[1])
                return display.leftPageIndexInAlbum > 1;
            },

            canMoveSpreadRight() {
                if (!this.canMoveOrDeleteSpread()) return false;
                const display = this.currentDisplayInfo;
                const N = this.album.pages.length;
                // Cannot move right if it's the last spread before a single last page, or the absolute last spread.
                // i.e., right page index is N-2 (if N is even, last is N-1 SL) or N-1 (if N is odd, last is part of spread)
                if (N % 2 === 0) { // Last page is single left (N-1)
                    return display.rightPageIndexInAlbum < N - 3; // Must be space for it before the one before SL
                } else { // Last page is right of a spread (N-1)
                    return display.rightPageIndexInAlbum < N - 2;
                }
            },

            moveSpread(direction) {
                if (!this.canMoveOrDeleteSpread()) return;
                const display = this.currentDisplayInfo;
                const idxL = display.leftPageIndexInAlbum;
                const idxR = display.rightPageIndexInAlbum;

                const spreadPages = this.album.pages.splice(idxL, 2); // Remove spread

                let newIndex;
                if (direction === 'left') {
                    if (!this.canMoveSpreadLeft()) { // Re-insert if check failed (should be caught by UI)
                        this.album.pages.splice(idxL, 0, ...spreadPages); return;
                    }
                    newIndex = idxL - 2;
                    this.currentViewIndex--;
                } else { // right
                    if (!this.canMoveSpreadRight()) { // Re-insert
                        this.album.pages.splice(idxL, 0, ...spreadPages); return;
                    }
                    newIndex = idxL + 2; // Splicing changes indices, so it's still relative to original idxL
                    this.currentViewIndex++;
                }
                this.album.pages.splice(newIndex, 0, ...spreadPages);
            },

            deleteSpread() {
                if (!this.canMoveOrDeleteSpread()) return;
                if (!confirm("Are you sure you want to delete this double-page spread? Images on it will be returned to the image bank.")) return;

                const display = this.currentDisplayInfo;
                const removedPages = this.album.pages.splice(display.leftPageIndexInAlbum, 2);

                removedPages.forEach(page => {
                    page.rows.forEach(row => {
                        row.columns.forEach(col => {
                            if (col.path) this.returnImageToBank(col.path);
                        });
                    });
                });
                
                // Adjust currentViewIndex if needed
                if (this.currentViewIndex > this.maxViewIndex) {
                    this.currentViewIndex = this.maxViewIndex;
                }
                if (this.currentViewIndex < 0 && this.maxViewIndex >=0) this.currentViewIndex = 0;

                this.updateImageBankStatusFromAlbum();
            },

            // --- Drag and Drop ---
            handleDragStartFromBank(event, image) {
                event.dataTransfer.setData('application/json', JSON.stringify({ type: 'image-bank', imagePath: image.path }));
                event.dataTransfer.effectAllowed = 'copyMove';
            },
            handleDragStartFromCell(event, pageId, rowIndex, colIndex) {
                const page = this.album.pages.find(p => p.id === pageId);
                const imagePath = page.rows[rowIndex].columns[colIndex].path;
                event.dataTransfer.setData('application/json', JSON.stringify({ 
                    type: 'cell', 
                    imagePath: imagePath,
                    sourcePageId: pageId,
                    sourceRowIndex: rowIndex,
                    sourceColIndex: colIndex
                }));
                event.dataTransfer.effectAllowed = 'move';
            },
            handleDragOverCell(event) {
                event.preventDefault(); // Necessary to allow drop
                event.currentTarget.style.backgroundColor = '#e9ecef'; // Highlight
            },
            handleDragLeaveCell(event) {
                event.currentTarget.style.backgroundColor = ''; // Remove highlight
            },
            handleDropOnCell(event, targetPageId, targetRowIndex, targetColIndex) {
                event.preventDefault();
                event.currentTarget.style.backgroundColor = ''; // Remove highlight
                const data = JSON.parse(event.dataTransfer.getData('application/json'));
                
                const targetPage = this.album.pages.find(p => p.id === targetPageId);
                if (!targetPage) return;
                const targetCell = targetPage.rows[targetRowIndex].columns[targetColIndex];
                const imageToDropPath = data.imagePath;

                // Image already in this cell?
                if (targetCell.path === imageToDropPath && data.type === 'cell' && data.sourcePageId === targetPageId && data.sourceRowIndex === targetRowIndex && data.sourceColIndex === targetColIndex) {
                    return; // Dropped on itself
                }

                // Return existing image in target cell to bank (if any)
                if (targetCell.path) {
                    this.returnImageToBank(targetCell.path);
                }

                // Place new image
                this.setImageInCell(targetPage, targetRowIndex, targetColIndex, imageToDropPath);
                this.markImageAsUsed(imageToDropPath, targetPageId, targetRowIndex, targetColIndex);

                // If dragged from another cell, clear the source cell
                if (data.type === 'cell') {
                    const sourcePage = this.album.pages.find(p => p.id === data.sourcePageId);
                    if (sourcePage) {
                        // If target cell originally had an image, and we are swapping
                        const originalTargetImagePath = targetCell.path; // This is before setImageInCell overwrites it
                                                                        // Actually, targetCell.path was returned to bank.
                                                                        // We need to capture it before returnImageToBank.
                        // This logic is simpler if we consider swap:
                        // If data.type === 'cell' and targetCell.path exists (before clearing), it's a swap.
                        // The current logic: source image moves to target. Target's original image (if any) goes to bank.
                        // If we want to swap:
                        // 1. Get source image details (path, crop)
                        // 2. Get target image details (path, crop)
                        // 3. Set source cell with target image details
                        // 4. Set target cell with source image details
                        // This is complex because of auto-cropping. Let's stick to spec: "swap them".
                        // For simplicity, current implementation: drag from cell A to B: A becomes empty, B gets A's image. B's original image goes to bank.
                        // To implement true swap:
                        if (data.sourcePageId === targetPageId && data.sourceRowIndex === targetRowIndex && data.sourceColIndex === targetColIndex) {
                            // Dropped on itself, do nothing
                        } else {
                            const imageFromTargetCellOriginalPath = targetCell.path; // Path of image originally in target cell
                            // Place dragged image into target cell
                            this.setImageInCell(targetPage, targetRowIndex, targetColIndex, imageToDropPath);
                            this.markImageAsUsed(imageToDropPath, targetPageId, targetRowIndex, targetColIndex);

                            // Clear source cell OR place original target image into source cell (for swap)
                            const sourceCell = sourcePage.rows[data.sourceRowIndex].columns[data.sourceColIndex];
                            if (imageFromTargetCellOriginalPath) { // If target cell had an image, move it to source (swap)
                                this.setImageInCell(sourcePage, data.sourceRowIndex, data.sourceColIndex, imageFromTargetCellOriginalPath);
                                this.markImageAsUsed(imageFromTargetCellOriginalPath, data.sourcePageId, data.sourceRowIndex, data.sourceColIndex);
                            } else { // Target cell was empty, so source cell becomes empty
                               this.clearCell(sourcePage, data.sourceRowIndex, data.sourceColIndex);
                            }
                        }
                    }
                }
                this.updateImageBankStatusFromAlbum(); // Refresh all usage status
                this.saveAlbumData();
            },

            handleDropOnGrayArea(event) { // Remove image from cell to bank
                const dataStr = event.dataTransfer.getData('application/json');
                if (!dataStr) return;
                const data = JSON.parse(dataStr);

                if (data.type === 'cell') {
                    const sourcePage = this.album.pages.find(p => p.id === data.sourcePageId);
                    if (sourcePage) {
                        const imagePath = sourcePage.rows[data.sourceRowIndex].columns[data.sourceColIndex].path;
                        this.clearCell(sourcePage, data.sourceRowIndex, data.sourceColIndex);
                        this.returnImageToBank(imagePath);
                        this.updateImageBankStatusFromAlbum();
                        this.saveAlbumData();
                    }
                }
            },

            setImageInCell(page, rowIndex, colIndex, imagePath) {
                const cell = page.rows[rowIndex].columns[colIndex];
                cell.path = imagePath;
                // Auto-crop (center crop) - requires image dimensions and cell dimensions
                // For now, we'll just set the path. Croppie will handle it, or getCropStyle will do basic.
                // To do it properly, we need to calculate crop here.
                const imageInBank = this.imagesInFolder.find(img => img.path === imagePath);
                if (imageInBank && imageInBank.dataUrl) {
                    const tempImg = new Image();
                    tempImg.onload = () => { // This is async, problematic for immediate save
                        const cropData = this.calculateAutoCrop(tempImg.naturalWidth, tempImg.naturalHeight, page, rowIndex, colIndex);
                        cell.crop = cropData;
                        // Force Alpine to re-render if it doesn't detect nested change.
                        // This might require a manual re-render trigger or ensuring deep reactivity.
                        // Alpine 3 should handle deep reactivity with this.album.pages.
                        this.saveAlbumData(); // Save after crop data is set
                    };
                    tempImg.src = imageInBank.dataUrl;
                } else {
                     delete cell.crop; // No image, no crop
                }
            },
            
            calculateAutoCrop(imgNaturalWidth, imgNaturalHeight, page, rowIndex, colIndex) {
                // This needs cell's aspect ratio.
                // Cell dimensions are relative (percentages). We need rendered aspect ratio.
                // This is a simplification. A robust solution would get rendered cell dimensions.
                // For now, center crop.
                const cellElement = document.querySelector(`.page[data-page-id='${page.id}'] .page-row[data-row-index='${rowIndex}'] .page-column[data-col-index='${colIndex}']`);
                if (!cellElement) return { x:0, y:0, width: imgNaturalWidth, height: imgNaturalHeight }; // Full image if cell not found

                const cellWidth = cellElement.offsetWidth;
                const cellHeight = cellElement.offsetHeight;
                if(cellWidth === 0 || cellHeight === 0) return { x:0, y:0, width: imgNaturalWidth, height: imgNaturalHeight };


                const cellAspect = cellWidth / cellHeight;
                const imgAspect = imgNaturalWidth / imgNaturalHeight;

                let cropWidth, cropHeight, cropX, cropY;

                if (imgAspect > cellAspect) { // Image is wider than cell (relatively)
                    cropHeight = imgNaturalHeight;
                    cropWidth = cropHeight * cellAspect;
                    cropX = (imgNaturalWidth - cropWidth) / 2;
                    cropY = 0;
                } else { // Image is taller than cell (relatively)
                    cropWidth = imgNaturalWidth;
                    cropHeight = cropWidth / cellAspect;
                    cropY = (imgNaturalHeight - cropHeight) / 2;
                    cropX = 0;
                }
                return { x: cropX, y: cropY, width: cropWidth, height: cropHeight };
            },

            clearCell(page, rowIndex, colIndex) {
                const cell = page.rows[rowIndex].columns[colIndex];
                delete cell.path;
                delete cell.crop;
            },
            markImageAsUsed(imagePath, pageId, rowIndex, colIndex) {
                const img = this.imagesInFolder.find(i => i.path === imagePath);
                if (img) {
                    img.used = true;
                    // Store location for easier navigation (optional)
                    img.pageId = pageId; 
                    img.rowIndex = rowIndex;
                    img.colIndex = colIndex;
                }
            },
            returnImageToBank(imagePath) {
                const img = this.imagesInFolder.find(i => i.path === imagePath);
                if (img) {
                    img.used = false;
                    delete img.pageId;
                    delete img.rowIndex;
                    delete img.colIndex;
                }
            },

            // --- Layout Change ---
            toggleLayoutMenu(pageIndexInAlbum, event) {
                const page = this.album.pages[pageIndexInAlbum];
                if (!page) return;

                // Determine if page is left or right in current view for menu positioning
                const display = this.currentDisplayInfo;
                let side = 'left'; // Default
                if (display.type === 'SINGLE_RIGHT') side = 'right';
                else if (display.type === 'SPREAD') {
                    if (display.rightPageIndexInAlbum === pageIndexInAlbum) side = 'right';
                }
                // SINGLE_LEFT is already 'left' by default

                this.layoutMenuTarget = { pageIndex: pageIndexInAlbum, side: side };
                
                const iconRect = event.currentTarget.getBoundingClientRect();
                if (side === 'left') {
                    this.layoutMenuPosition = { top: `${iconRect.bottom + 5}px`, left: `${iconRect.left}px` };
                } else { // right
                    // This needs menu width to align right edge. For now, approx.
                    this.layoutMenuPosition = { top: `${iconRect.bottom + 5}px`, right: `${window.innerWidth - iconRect.right}px`, left: 'auto' };
                }
                this.showLayoutMenu = !this.showLayoutMenu;
            },

            applyLayoutChange(pageIndex, newLayoutKey) {
                this.showLayoutMenu = false;
                const page = this.album.pages[pageIndex];
                const oldLayoutKey = page.layout;
                if (oldLayoutKey === newLayoutKey) return;

                const newLayoutStructure = PREDEFINED_LAYOUTS[newLayoutKey];
                const oldImages = []; // Store {path, crop, originalCell: {row, col}}
                page.rows.forEach((r, rIdx) => r.columns.forEach((c, cIdx) => {
                    if (c.path) oldImages.push({path: c.path, crop: c.crop, originalRow: rIdx, originalCol: cIdx});
                }));

                // Create new page structure
                page.rows = JSON.parse(JSON.stringify(newLayoutStructure.rows));
                page.layout = newLayoutKey;

                // Try to preserve images based on rules
                // Rule of thumb: keep as much as possible. Recrop if cell dimensions change.
                // Specific strategies:
                if (newLayoutKey === '1') {
                    if (oldImages.length > 0) {
                        this.setImageInCell(page, 0, 0, oldImages[0].path); // Keep first image
                        // Return others to bank
                        oldImages.slice(1).forEach(img => this.returnImageToBank(img.path));
                    }
                } else if (oldLayoutKey === '1' && oldImages.length > 0) { // From '1' to multi-cell
                    this.setImageInCell(page, 0, 0, oldImages[0].path); // Place in top-left
                } else if (oldLayoutKey === '2-3' && newLayoutKey === '2-2') {
                    // Top row: keep first 2 images. 3rd image (if any at page.rows[0].columns[2] originally) goes to bank.
                    // Bottom row: unchanged (2-3 bottom has 3 cols, 2-2 bottom has 2 cols. This needs more thought)
                    // Spec: "from '2-3' to '2-2'. Drop the 3rd image in the top row." - This is ambiguous.
                    // '2-3' top: 2 cols (4,8). '2-2' top: 2 cols (6,6).
                    // Let's assume it means if the old layout *could* hold more images in a conceptual grid.
                    // Sticking to spec: "Drop the 3rd image in the top row." - 2-3 top has 2 images.
                    // This rule seems to imply a different understanding of "2-3" or a typo.
                    // Let's assume "2-3" (2 top, 3 bottom) to "2-2" (2 top, 2 bottom)
                    // Images from old page.rows[0].columns[0,1] -> new page.rows[0].columns[0,1]
                    // Images from old page.rows[1].columns[0,1] -> new page.rows[1].columns[0,1]
                    // Image from old page.rows[1].columns[2] (if any) -> bank
                    let placedImages = 0;
                    const newImagesToPlace = [];
                    oldImages.forEach(imgInfo => { // Try to map old positions to new if structure is similar
                        if (imgInfo.originalRow === 0 && imgInfo.originalCol < 2) { // Top row, first two
                            newImagesToPlace.push({ ...imgInfo, targetRow: 0, targetCol: imgInfo.originalCol });
                        } else if (imgInfo.originalRow === 1 && imgInfo.originalCol < 2) { // Bottom row, first two
                            newImagesToPlace.push({ ...imgInfo, targetRow: 1, targetCol: imgInfo.originalCol });
                        } else {
                            this.returnImageToBank(imgInfo.path);
                        }
                    });
                    newImagesToPlace.forEach(img => this.setImageInCell(page, img.targetRow, img.targetCol, img.path));

                } else if (oldLayoutKey === '3-2' && newLayoutKey === '2-2') {
                    // Similar logic: keep top 2 (from 3), bottom 2 (from 2)
                    let placedImages = 0;
                    const newImagesToPlace = [];
                    oldImages.forEach(imgInfo => {
                        if (imgInfo.originalRow === 0 && imgInfo.originalCol < 2) { // Top row, first two
                            newImagesToPlace.push({ ...imgInfo, targetRow: 0, targetCol: imgInfo.originalCol });
                        } else if (imgInfo.originalRow === 1 && imgInfo.originalCol < 2) { // Bottom row (already 2)
                            newImagesToPlace.push({ ...imgInfo, targetRow: 1, targetCol: imgInfo.originalCol });
                        } else {
                            this.returnImageToBank(imgInfo.path);
                        }
                    });
                    newImagesToPlace.forEach(img => this.setImageInCell(page, img.targetRow, img.targetCol, img.path));

                } else if ((oldLayoutKey === '3-2' && newLayoutKey === '2-3') || (oldLayoutKey === '2-3' && newLayoutKey === '3-2')) {
                    // Swap rows. Images stay in their relative column index within the swapped row.
                    const oldRow0Images = oldImages.filter(img => img.originalRow === 0);
                    const oldRow1Images = oldImages.filter(img => img.originalRow === 1);
                    oldRow0Images.forEach(img => this.setImageInCell(page, 1, img.originalCol, img.path)); // Old R0 -> New R1
                    oldRow1Images.forEach(img => this.setImageInCell(page, 0, img.originalCol, img.path)); // Old R1 -> New R0
                
                } else if (oldLayoutKey === '2-2' && (newLayoutKey === '2-3' || newLayoutKey === '3-2')) {
                    // Keep existing images, new cells are empty.
                    oldImages.forEach(img => {
                        // Check if target cell exists
                        if (page.rows[img.originalRow] && page.rows[img.originalRow].columns[img.originalCol]) {
                           this.setImageInCell(page, img.originalRow, img.originalCol, img.path);
                        } else {
                            this.returnImageToBank(img.path); // Should not happen if new layout is larger or same
                        }
                    });
                } else { // Generic: fill new layout from top-left with old images, return excess
                    let imageIdx = 0;
                    for (let r = 0; r < page.rows.length; r++) {
                        for (let c = 0; c < page.rows[r].columns.length; c++) {
                            if (imageIdx < oldImages.length) {
                                this.setImageInCell(page, r, c, oldImages[imageIdx].path);
                                imageIdx++;
                            }
                        }
                    }
                    for (let i = imageIdx; i < oldImages.length; i++) {
                        this.returnImageToBank(oldImages[i].path);
                    }
                }

                // Recalculate auto-crops for all images in the new layout
                page.rows.forEach((row, rIdx) => {
                    row.columns.forEach((col, cIdx) => {
                        if (col.path) {
                            const imageInBank = this.imagesInFolder.find(img => img.path === col.path);
                            if (imageInBank && imageInBank.dataUrl) {
                                const tempImg = new Image();
                                tempImg.onload = () => {
                                    col.crop = this.calculateAutoCrop(tempImg.naturalWidth, tempImg.naturalHeight, page, rIdx, cIdx);
                                    this.saveAlbumData(); // Save after crop data is set
                                };
                                tempImg.src = imageInBank.dataUrl;
                            }
                        }
                    });
                });
                this.updateImageBankStatusFromAlbum();
                this.saveAlbumData();
            },

            // --- Cropping (Croppie.js) ---
            openCropModal(pageId, rowIndex, colIndex) {
                const page = this.album.pages.find(p => p.id === pageId);
                const cell = page.rows[rowIndex].columns[colIndex];
                const imageInBank = this.imagesInFolder.find(img => img.path === cell.path);

                if (!imageInBank || !imageInBank.dataUrl) return;

                // Calculate cell aspect ratio for Croppie
                const cellElement = document.querySelector(`.page[data-page-id='${pageId}'] .page-row[data-row-index='${rowIndex}'] .page-column[data-col-index='${colIndex}']`);
                const cellWidth = cellElement.offsetWidth;
                const cellHeight = cellElement.offsetHeight;
                const cellAspectRatio = cellWidth / cellHeight;

                this.croppingContext = { 
                    pageId, rowIndex, colIndex, path: cell.path, 
                    currentCrop: cell.crop, // This is {x,y,width,height} on original
                    imageElement: imageInBank, // For dataUrl
                    cellAspectRatio: cellAspectRatio
                };

                this.showCropModal = true;
                this.$nextTick(() => {
                    const croppieContainer = document.getElementById('croppie-container');
                    if (this.croppieInstance) {
                        this.croppieInstance.destroy();
                    }
                    
                    // Calculate viewport dimensions based on cell aspect ratio
                    const containerWidth = croppieContainer.offsetWidth * 0.95;
                    const containerHeight = croppieContainer.offsetHeight * 0.95;
                    const vpWidth = Math.min(containerWidth * 0.8, (containerHeight * 0.8) * cellAspectRatio);
                    const vpHeight = vpWidth / cellAspectRatio;
                    
                    this.croppieInstance = new Croppie(croppieContainer, {
                        viewport: { width: Math.round(vpWidth), height: Math.round(vpHeight), type: 'square' },
                        boundary: { width: containerWidth, height: containerHeight },
                        enableExif: true,
                        enforceBoundary: true,
                    });

                    let initialPoints = null;
                    if (cell.crop && cell.crop.width > 0) { // Existing crop
                        // Convert original crop {x,y,w,h} to Croppie points [x1,y1,x2,y2]
                        // This requires knowing the zoom level Croppie would use to display this.
                        // This is complex. A simpler way is to let Croppie center it and user re-adjusts.
                        // Or, if we have original image dimensions:
                        // const img = new Image(); img.src = imageInBank.dataUrl;
                        // img.onload = () => { ... } // Async
                        // For now, let Croppie auto-center. User can refine.
                    }

                    this.croppieInstance.bind({
                        url: imageInBank.dataUrl,
                        points: initialPoints ? initialPoints.points : null, // Croppie wants points array
                        zoom: initialPoints ? initialPoints.zoom : null
                        // orientation: 1 // Default, EXIF will handle
                    });
                });
            },
            cancelCrop() {
                this.showCropModal = false;
                if (this.croppieInstance) {
                    this.croppieInstance.destroy();
                    this.croppieInstance = null;
                }
            },
            async saveCrop() {
                if (!this.croppieInstance) return;

                const result = await this.croppieInstance.result({
                    type: 'rawcanvas', // Gives us the canvas itself
                    size: 'original',  // Crop coordinates relative to original image size
                    format: 'png',     // Format doesn't matter much for rawcanvas coords
                    circle: false
                });
                
                // The `result` from 'rawcanvas' with 'original' size gives a new canvas
                // where the cropped part of the original image is drawn at its original resolution.
                // The canvas dimensions are `result.width`, `result.height`.
                // The top-left of this canvas corresponds to `result.x`, `result.y` on the original image.
                // So, the crop details are:
                // x: result.x (from Croppie's internal calculation of where the crop starts on original)
                // y: result.y
                // width: result.width (width of the cropped selection at original resolution)
                // height: result.height (height of the cropped selection at original resolution)
                // This seems to be what Croppie's `get()` method provides in a more direct way.
                
                const cropDataFromCroppie = this.croppieInstance.get(); // { points: [x1,y1,x2,y2], zoom: number, orientation: number }
                                                                    // points are viewport coordinates of the crop area.
                
                // We need to convert Croppie's viewport crop `points` and `zoom` to `x,y,width,height` on the original image.
                const img = new Image();
                img.src = this.croppingContext.imageElement.dataUrl;
                await new Promise(resolve => img.onload = resolve); // Ensure image is loaded for naturalW/H

                const originalWidth = img.naturalWidth;
                const originalHeight = img.naturalHeight;

                // Croppie's `get()` method returns points relative to the *displayed* image in the Croppie UI.
                // The displayed image is already zoomed.
                // x_orig = (points[0] - boundary_offset_x_if_any) / zoom
                // y_orig = (points[1] - boundary_offset_y_if_any) / zoom
                // w_orig = (points[2] - points[0]) / zoom
                // h_orig = (points[3] - points[1]) / zoom
                // This needs to account for how Croppie positions the (zoomed) image within its boundary.
                // It's usually centered.
                
                // A more reliable way might be to use the `result` from type:'canvas' or 'html' and inspect its transform.
                // However, the spec for `album.json` implies `x,y,width,height` on the original image.
                // Let's assume `croppieInstance.result({type: 'canvas', size: 'original'})` would give a canvas
                // whose dimensions are the cropWidth/Height at original scale, and we'd need its offset.
                // The documentation for `result({ type: 'rawcanvas', size: 'original' })` is often misunderstood.
                // It actually returns the *cropped part* drawn onto a *new canvas*, scaled to its original pixel size.
                // The coordinates of this new canvas relative to the original image are NOT directly given.
                
                // Let's use the `get()` method and transform points.
                const { points, zoom } = cropDataFromCroppie; // points are [x1, y1, x2, y2] of the crop rectangle in the viewport
                const crBoundRect = this.croppieInstance.elements.boundary.getBoundingClientRect();
                const crImgRect = this.croppieInstance.elements.img.getBoundingClientRect(); // The displayed, transformed image

                // Offset of the displayed image within the Croppie boundary
                const imgDisplayOffsetX = crImgRect.left - crBoundRect.left;
                const imgDisplayOffsetY = crImgRect.top - crBoundRect.top;

                // Crop coordinates relative to the (zoomed, panned) displayed image
                const cropXonDisplayedImg = points[0] - imgDisplayOffsetX;
                const cropYonDisplayedImg = points[1] - imgDisplayOffsetY;

                // Convert to coordinates on the original, unzoomed image
                const finalCrop = {
                    x: Math.round(cropXonDisplayedImg / zoom),
                    y: Math.round(cropYonDisplayedImg / zoom),
                    width: Math.round((points[2] - points[0]) / zoom),
                    height: Math.round((points[3] - points[1]) / zoom)
                };

                const page = this.album.pages.find(p => p.id === this.croppingContext.pageId);
                page.rows[this.croppingContext.rowIndex].columns[this.croppingContext.colIndex].crop = finalCrop;
                
                this.cancelCrop(); // Destroys instance, hides modal
                this.saveAlbumData();
            },

            // --- Resizing Gutters ---
            startResize(event, type, pageId, rowIndex, colIndex = null) {
                this.isResizing = true;
                this.resizeContext.type = type;
                this.resizeContext.pageElement = event.target.closest('.page');
                this.resizeContext.pageContentElement = event.target.closest('.page-content-area');
                this.resizeContext.pageId = pageId;
                this.resizeContext.rowIndex = rowIndex;
                this.resizeContext.colIndex = colIndex; // For column resize, this is the index of the LEFT column of the gutter
                this.resizeContext.gutterElement = event.target;
                this.resizeContext.startX = event.clientX;
                this.resizeContext.startY = event.clientY;

                const page = this.album.pages.find(p => p.id === pageId);
                if (type === 'row') {
                    this.resizeContext.initialSizes = [
                        page.rows[rowIndex].height_percent,
                        page.rows[rowIndex + 1].height_percent
                    ];
                } else { // column
                    const row = page.rows[rowIndex];
                    this.resizeContext.initialSizes = [
                        row.columns[colIndex].width_grid,
                        row.columns[colIndex + 1].width_grid
                    ];
                    if (row.columns.length === 3 && colIndex === 0) { // Dragging first gutter in 3-col row
                        this.resizeContext.fixedSize = row.columns[2].width_grid; // Third col is fixed
                        this.resizeContext.totalAdjacentSize = row.columns[0].width_grid + row.columns[1].width_grid;
                    } else if (row.columns.length === 3 && colIndex === 1) { // Dragging second gutter
                         this.resizeContext.fixedSize = row.columns[0].width_grid; // First col is fixed
                         this.resizeContext.totalAdjacentSize = row.columns[1].width_grid + row.columns[2].width_grid;
                    }
                }
                
                const mouseMoveHandler = (e) => this.doResize(e);
                const mouseUpHandler = (e) => {
                    document.removeEventListener('mousemove', mouseMoveHandler);
                    document.removeEventListener('mouseup', mouseUpHandler);
                    this.stopResize(e);
                };

                document.addEventListener('mousemove', mouseMoveHandler);
                document.addEventListener('mouseup', mouseUpHandler);
            },

            doResize(event) {
                if (!this.isResizing) return;
                event.preventDefault();

                const dx = event.clientX - this.resizeContext.startX;
                const dy = event.clientY - this.resizeContext.startY;

                const page = this.album.pages.find(p => p.id === this.resizeContext.pageId);

                if (this.resizeContext.type === 'row') {
                    const pageContentHeightPx = this.resizeContext.pageContentElement.offsetHeight; // Rendered height
                    if (pageContentHeightPx === 0) return; // Prevent division by zero
                    const totalPctToDistribute = this.resizeContext.initialSizes[0] + this.resizeContext.initialSizes[1];
                    let deltaPercent = (dy / pageContentHeightPx) * 100; // Convert pixel delta to percent of content area

                    let newHeight1 = this.resizeContext.initialSizes[0] + deltaPercent;
                    let newHeight2 = this.resizeContext.initialSizes[1] - deltaPercent;

                    // Min height 10% (heuristic)
                    const minPct = 10;
                    if (newHeight1 < minPct) {
                        newHeight1 = minPct;
                        newHeight2 = totalPctToDistribute - minPct;
                    }
                    if (newHeight2 < minPct) {
                        newHeight2 = minPct;
                        newHeight1 = totalPctToDistribute - newHeight2;
                    }
                    
                    page.rows[this.resizeContext.rowIndex].height_percent = parseFloat(newHeight1.toFixed(1));
                    page.rows[this.resizeContext.rowIndex + 1].height_percent = parseFloat(newHeight2.toFixed(1));

                } else { // column
                    const rowElement = this.resizeContext.gutterElement.closest('.page-row');
                    const rowContentWidthPx = rowElement.offsetWidth; // Rendered width of the row (content part)
                    if (rowContentWidthPx === 0) return; // Prevent division by zero
                    
                    let deltaGrid = (dx / rowContentWidthPx) * 12; // Convert pixel delta to grid units (out of 12)

                    const colIdx1 = this.resizeContext.colIndex;
                    const colIdx2 = this.resizeContext.colIndex + 1;
                    const row = page.rows[this.resizeContext.rowIndex];

                    let newGrid1 = Math.round(this.resizeContext.initialSizes[0] + deltaGrid);
                    let newGrid2;

                    if (row.columns.length === 3 && (this.resizeContext.colIndex === 0 || this.resizeContext.colIndex === 1)) {
                        // Special handling for 3-column rows: "only the two columns adjacent to the dragged gutter should change their width; their combined width remains constant."
                        // This means the sum of the two adjacent columns' width_grid should be preserved.
                        const totalAdjacentInitialGrid = this.resizeContext.totalAdjacentSize;
                        
                        newGrid1 = Math.round(this.resizeContext.initialSizes[0] + deltaGrid);
                        // Clamp newGrid1 (e.g., min 1 unit)
                        newGrid1 = Math.max(1, Math.min(newGrid1, totalAdjacentInitialGrid - 1));
                        newGrid2 = totalAdjacentInitialGrid - newGrid1;

                        row.columns[colIdx1].width_grid = newGrid1;
                        row.columns[colIdx2].width_grid = newGrid2;
                        // The third column (fixedSize) remains unchanged.
                    } else { // Standard 2-column resize or other cases (though spec focuses on 3-col)
                        const totalGridToDistribute = this.resizeContext.initialSizes[0] + this.resizeContext.initialSizes[1];
                        newGrid1 = Math.round(this.resizeContext.initialSizes[0] + deltaGrid);
                        // Clamp (min 1 grid unit)
                        newGrid1 = Math.max(1, Math.min(newGrid1, totalGridToDistribute - 1));
                        newGrid2 = totalGridToDistribute - newGrid1;
                        
                        row.columns[colIdx1].width_grid = newGrid1;
                        row.columns[colIdx2].width_grid = newGrid2;
                    }
                }
                // Alpine should react and re-render.
            },

            stopResize(event) {
                if (!this.isResizing) return;
                this.isResizing = false;

                // Auto-recrop images in affected cells
                const page = this.album.pages.find(p => p.id === this.resizeContext.pageId);
                const affectedCells = [];
                if (this.resizeContext.type === 'row') {
                    page.rows[this.resizeContext.rowIndex].columns.forEach((col, cIdx) => {
                        if (col.path) affectedCells.push({ page, rIdx: this.resizeContext.rowIndex, cIdx });
                    });
                    page.rows[this.resizeContext.rowIndex + 1].columns.forEach((col, cIdx) => {
                        if (col.path) affectedCells.push({ page, rIdx: this.resizeContext.rowIndex + 1, cIdx });
                    });
                } else { // column
                    const rIdx = this.resizeContext.rowIndex;
                    const cIdx1 = this.resizeContext.colIndex;
                    const cIdx2 = cIdx1 + 1;
                    if (page.rows[rIdx].columns[cIdx1].path) affectedCells.push({ page, rIdx, cIdx: cIdx1 });
                    if (page.rows[rIdx].columns[cIdx2].path) affectedCells.push({ page, rIdx, cIdx: cIdx2 });
                }
                
                this.$nextTick(() => { // Ensure DOM is updated before measuring for crop
                    affectedCells.forEach(cellInfo => {
                        const imageInBank = this.imagesInFolder.find(img => img.path === cellInfo.page.rows[cellInfo.rIdx].columns[cellInfo.cIdx].path);
                        if (imageInBank && imageInBank.dataUrl) {
                            const tempImg = new Image();
                            tempImg.onload = () => {
                                cellInfo.page.rows[cellInfo.rIdx].columns[cellInfo.cIdx].crop = this.calculateAutoCrop(tempImg.naturalWidth, tempImg.naturalHeight, cellInfo.page, cellInfo.rIdx, cellInfo.cIdx);
                                this.saveAlbumData();
                            };
                            tempImg.src = imageInBank.dataUrl;
                        }
                    });
                });
                this.saveAlbumData(); // Save structural changes
            },
            
            // Utility
            generateUUID() {
                return crypto.randomUUID();
            }
        }
    }

    // Need to re-bind Alpine and Bootstrap components if content is dynamically replaced by x-html
    // For Alpine, this is generally handled if the x-html is within an x-data scope.
    // For Bootstrap dropdowns, they might need re-initialization if the button group itself is re-rendered.
    // The current structure keeps the main controls static, so it should be fine.
    // Resizing gutters are added via x-html, their @mousedown events are handled by Alpine.
    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>