<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Family Album Photobook Builder</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/croppie/2.6.5/croppie.min.css" rel="stylesheet">
    <style>
        body, html {
            height: 100%;
            margin: 0;
            font-family: sans-serif;
            overflow: hidden; /* Prevent body scroll, manage scrolling in panels */
        }
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        .top-bar {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }
        .main-area {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f0f0f0;
            overflow: hidden; /* Important for scaling */
            position: relative; /* For absolute positioning of layout change icons */
        }
        .album-preview-scaler {
            transform-origin: center center; /* Or top left if preferred */
        }
        .album-pages-container {
            display: flex;
            background-color: #ddd; /* Area behind pages */
        }
        .page {
            background-color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            position: relative; /* For layout change icon and gutters */
            overflow: hidden; /* To contain images */
        }
        .page-content {
            margin: 1cm; /* Outer edge margin */
            height: calc(100% - 2cm);
            width: calc(100% - 2cm);
            display: flex;
            flex-direction: column;
        }
        .page-row {
            display: flex;
            width: 100%;
        }
        .page-row:not(:last-child) {
            margin-bottom: 0.5cm; /* Gutter between rows */
        }
        .page-column {
            background-color: #f9f9f9;
            border: 1px dashed #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden; /* Crucial for cropped image display */
        }
        .page-column:not(:last-child) {
            margin-right: 0.5cm; /* Gutter between columns */
        }
        .page-column img.dropped-image {
            position: absolute; /* Will be controlled by JS for crop */
            object-fit: none; /* We control this via x,y,width,height logic */
        }
        .empty-cell-text {
            color: #aaa;
            font-size: 0.8em;
        }
        .image-bank {
            height: 160px;
            background-color: #333;
            color: white;
            padding: 5px;
            display: flex;
            overflow-x: auto;
            overflow-y: hidden;
            align-items: center; /* Vertically center thumbnails */
        }
        .image-bank-thumb {
            height: 150px;
            margin-right: 10px;
            cursor: grab;
            transition: transform 0.2s ease-in-out;
            border: 2px solid transparent;
        }
        .image-bank-thumb:hover {
            transform: scale(1.1);
        }
        .image-bank-thumb.used {
            filter: grayscale(100%) opacity(0.5);
            cursor: pointer;
        }
        .image-bank-thumb.dragging {
            opacity: 0.5;
        }

        /* Gutters */
        .row-gutter, .col-gutter {
            position: absolute;
            background-color: rgba(200, 200, 200, 0); /* Transparent initially */
            transition: background-color 0.2s;
            z-index: 10;
        }
        .row-gutter {
            height: 0.5cm;
            width: 100%; /* Stretches across page content width */
            cursor: row-resize;
        }
        .col-gutter {
            width: 0.5cm;
            height: 100%; /* Stretches across row height */
            cursor: col-resize;
        }
        .row-gutter:hover, .col-gutter:hover {
            background-color: rgba(150, 150, 150, 0.5);
        }

        /* Layout change icon */
        .layout-change-button {
            position: absolute;
            top: -5px; /* Adjust to be slightly outside the 1cm margin */
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            padding: 5px;
            cursor: pointer;
            z-index: 20;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        .layout-change-button.left-page { left: -5px; }
        .layout-change-button.right-page { right: -5px; }
        .layout-menu {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 21;
            padding: 5px;
            min-width: 100px;
        }
        .layout-menu button {
            display: block;
            width: 100%;
            text-align: left;
            margin-bottom: 5px;
            white-space: pre; /* For unicode layout characters */
            font-family: monospace; /* For better block character rendering */
            font-size: 1.2em;
        }

        /* Croppie Modal */
        .croppie-modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
        }
        .croppie-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
        }

        [x-cloak] { display: none !important; }

        /* For page number display */
        .page-number-display {
            position: absolute;
            bottom: 10px; /* Relative to main-area */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="app-container" x-data="albumBuilder()" x-init="initApp()" x-cloak>
        <!-- Top Right Buttons -->
        <div class="top-bar" x-show="directoryHandle">
            <div class="btn-group me-2" role="group" aria-label="Navigation">
                <button type="button" class="btn btn-light" @click="prevPage()" :disabled="!canGoPrev()" title="Previous page">
                    <i class="bi bi-arrow-left"></i>
                </button>
                <button type="button" class="btn btn-light" @click="nextPage()" :disabled="!canGoNext()" title="Next page">
                    <i class="bi bi-arrow-right"></i>
                </button>
            </div>
            <div class="btn-group" role="group" aria-label="Page Actions">
                <button type="button" class="btn btn-light" @click="addPage()" :disabled="!canAddPage()" title="Add double page after current"
                        :title="canAddPage() ? 'Add double page after current' : 'Cannot add page after the last page'">
                    <i class="bi bi-plus"></i>
                </button>
                <div class="btn-group" role="group">
                    <button id="movePageDropdown" type="button" class="btn btn-light dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false"
                            :disabled="!canMovePage()" title="Move current double page"
                            :title="canMovePage() ? 'Move current double page' : 'Single pages or boundary double pages cannot be moved'">
                        <i class="bi bi-arrow-left-right"></i>
                    </button>
                    <ul class="dropdown-menu" aria-labelledby="movePageDropdown">
                        <li><button class="dropdown-item" @click="movePageRelative(-1)" :disabled="!canMovePageLeft()" title="Move left"><i class="bi bi-arrow-bar-left"></i> Move Left</button></li>
                        <li><button class="dropdown-item" @click="movePageRelative(1)" :disabled="!canMovePageRight()" title="Move right"><i class="bi bi-arrow-bar-right"></i> Move Right</button></li>
                    </ul>
                </div>
                <button type="button" class="btn btn-light" @click="deleteCurrentPage()" :disabled="!canDeletePage()" title="Delete current double page"
                        :title="canDeletePage() ? 'Delete current double page' : 'Cannot delete first or last page'">
                    <i class="bi bi-trash"></i>
                </button>
            </div>
        </div>

        <!-- Main Area -->
        <div class="main-area" x-ref="mainArea" @dragover.prevent @drop.prevent="handleDropOnMainArea($event)">
            <div x-show="!directoryHandle" class="text-center">
                <p>Select a folder containing your JPEG images to get started.</p>
                <button class="btn btn-primary" @click="selectFolder()">Select Image Folder</button>
                <p x-show="error" class="text-danger mt-2" x-text="error"></p>
            </div>

            <div x-show="directoryHandle && album.pages.length > 0" class="album-preview-scaler" :style="getScalerStyle()">
                <div class="album-pages-container">
                    <template x-for="(page, pageArrayIndex) in currentPagesToDisplay" :key="page.id">
                        <div class="page" :style="getPageStyle()">
                            <!-- Layout Change Icon -->
                            <div x-show="!isSinglePage(pageArrayIndex) || (isSinglePage(pageArrayIndex) && currentPagesToDisplay.length === 1)"
                                 class="layout-change-button"
                                 :class="{ 'left-page': isLeftPage(pageArrayIndex), 'right-page': isRightPage(pageArrayIndex) }"
                                 @click.stop="toggleLayoutMenu(page.id, isLeftPage(pageArrayIndex))"
                                 :title="isPageSingleType(page) ? 'Layout is fixed for single pages' : 'Change layout'"
                                 :style="{ 'cursor': isPageSingleType(page) ? 'not-allowed' : 'pointer' }">
                                <i class="bi bi-grid-fill"></i>
                                <!-- Layout Menu -->
                                <div x-show="layoutMenu.visible && layoutMenu.pageId === page.id" class="layout-menu">
                                    <template x-for="layoutKey in Object.keys(layoutIcons)" :key="layoutKey">
                                        <button class="btn btn-sm btn-outline-secondary" @click.stop="changePageLayout(page.id, layoutKey)">
                                            <span x-html="layoutIcons[layoutKey]"></span>
                                        </button>
                                    </template>
                                </div>
                            </div>

                            <div class="page-content">
                                <template x-for="(row, rowIndex) in page.rows" :key="rowIndex">
                                    <div class="page-row" :style="getRowStyle(page, rowIndex)">
                                        <template x-for="(col, colIndex) in row.columns" :key="colIndex">
                                            <div class="page-column dropzone"
                                                 :style="getColumnStyle(page, rowIndex, colIndex)"
                                                 @dragover.prevent="handleDragOverCell($event, page.id, rowIndex, colIndex)"
                                                 @dragleave.prevent="handleDragLeaveCell($event, page.id, rowIndex, colIndex)"
                                                 @drop.prevent="handleDropOnCell($event, page.id, rowIndex, colIndex)"
                                                 @dblclick="col.path ? openCropper(page.id, rowIndex, colIndex, col.path) : null"
                                                 :data-page-id="page.id" :data-row-index="rowIndex" :data-col-index="colIndex"
                                                 :title="col.path ? 'Double click to crop' : 'Drag image here'">
                                                
                                                <img x-if="col.path && imageExists(col.path)" 
                                                     :src="getImageByPath(col.path)?.url"
                                                     class="dropped-image" 
                                                     :style="getCroppedImageStyle(col, page, rowIndex, colIndex)"
                                                     draggable="true"
                                                     @dragstart="handleDragStartFromCell($event, page.id, rowIndex, colIndex, col.path)">
                                                
                                                <span x-show="!col.path" class="empty-cell-text">Empty</span>
                                            </div>
                                            <!-- Column Gutter -->
                                            <div x-if="colIndex < row.columns.length - 1"
                                                 class="col-gutter"
                                                 :style="getColGutterStyle(page, rowIndex, colIndex)"
                                                 @mousedown="initColResize($event, page.id, rowIndex, colIndex)">
                                            </div>
                                        </template>
                                    </div>
                                    <!-- Row Gutter -->
                                    <div x-if="rowIndex < page.rows.length - 1"
                                         class="row-gutter"
                                         :style="getRowGutterStyle(page, rowIndex)"
                                         @mousedown="initRowResize($event, page.id, rowIndex)">
                                    </div>
                                </template>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
            <div x-show="directoryHandle && album.pages.length > 0" class="page-number-display" x-text="getPageNumberText()"></div>
        </div>

        <!-- Image Bank -->
        <div class="image-bank" x-show="directoryHandle" 
             @dragover.prevent @drop.prevent="handleDropOnImageBank($event)">
            <template x-for="image in sortedImages" :key="image.path">
                <img :src="image.url"
                     class="image-bank-thumb"
                     :class="{ 'used': image.used, 'dragging': draggedImage && draggedImage.path === image.path }"
                     :title="image.name"
                     draggable="true"
                     @dragstart="handleDragStartFromBank($event, image)"
                     @dragend="draggedImage = null"
                     @click="image.used ? goToPageOfImage(image.path) : null">
            </template>
            <div x-show="images.length === 0 && directoryHandle" class="p-3 text-muted">No JPG images found in the selected folder.</div>
        </div>

        <!-- Croppie Modal -->
        <div x-show="showCropperModal" class="croppie-modal" @click.self="closeCropper()">
            <div class="croppie-container">
                <div x-ref="croppieEl"></div>
                <button class="btn btn-primary mt-3" @click="saveCrop()">Save Crop</button>
                <button class="btn btn-secondary mt-3 ms-2" @click="closeCropper()">Cancel</button>
            </div>
        </div>

        <!-- Loading indicator -->
        <div x-show="isLoading" style="position:fixed; top:0;left:0;width:100%;height:100%;background:rgba(255,255,255,0.8);display:flex;justify-content:center;align-items:center;z-index:9999;">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/croppie/2.6.5/croppie.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/exif-js@2.3.0/exif.js"></script>
    <!-- Interact.js is not used directly for resizable, but for drag/drop. Resize is custom. -->
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>


    <script>
    // Constants
    const PHOTOBOOK_VERSION = "0.1";
    const PAGE_WIDTH_CM = 35;
    const PAGE_HEIGHT_CM = 29;
    const PAGE_MARGIN_CM = 1;
    const GUTTER_CM = 0.5;
    const TOTAL_GRID_UNITS = 12;
    const PX_PER_CM = 37.795; // Approx 96 DPI

    const LAYOUT_DEFINITIONS = {
        "1": { name: "1", rows: [{ height_percent: 100, columns: [{ width_grid: 12 }] }] },
        "2-2": { name: "2-2", rows: [
            { height_percent: 50, columns: [{ width_grid: 6 }, { width_grid: 6 }] },
            { height_percent: 50, columns: [{ width_grid: 6 }, { width_grid: 6 }] }
        ]},
        "2-3": { name: "2-3", rows: [
            { height_percent: 50, columns: [{ width_grid: 4 }, { width_grid: 8 }] },
            { height_percent: 50, columns: [{ width_grid: 4 }, { width_grid: 4 }, { width_grid: 4 }] }
        ]},
        "3-2": { name: "3-2", rows: [
            { height_percent: 50, columns: [{ width_grid: 4 }, { width_grid: 4 }, { width_grid: 4 }] },
            { height_percent: 50, columns: [{ width_grid: 6 }, { width_grid: 6 }] }
        ]}
    };

    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    document.addEventListener('alpine:init', () => {
        Alpine.data('albumBuilder', () => ({
            // State
            directoryHandle: null,
            images: [], // { path, name, url, exifData, used, naturalWidth, naturalHeight }
            album: { photobook_version: PHOTOBOOK_VERSION, pages: [] },
            currentPageIndex: 0, // Index in album.pages for the LEFT page of a spread, or single page
            scaleFactor: 0.5,
            isLoading: false,
            error: '',
            
            croppieInstance: null,
            croppingImageInfo: null, // { pageId, rowIndex, colIndex, path, cellAspectRatio }
            showCropperModal: false,

            draggedImage: null, // { path, name, url, ... } from bank OR { pageId, rowIndex, colIndex, path } from cell
            
            layoutMenu: { visible: false, pageId: null, isLeft: false },

            layoutIcons: { // Using pre for multiline
                "1":   "█",
                "2-2": "▓▓\n▓▓",
                "2-3": "▓▓\n▒▒▒",
                "3-2": "▒▒▒\n▓▓",
            },

            // Resizing state
            resizing: null, // { type: 'row'/'col', pageId, rowIndex, colIndex (for col), initialMouse, initialSizes }

            // Computed properties
            get sortedImages() {
                return [...this.images].sort((a, b) => {
                    const dateA = a.exifData?.DateTimeOriginal || a.exifData?.DateTime;
                    const dateB = b.exifData?.DateTimeOriginal || b.exifData?.DateTime;
                    if (dateA && dateB) {
                        const dA = new Date(dateA.replace(/(\d{4}):(\d{2}):(\d{2})/, '$1-$2-$3'));
                        const dB = new Date(dateB.replace(/(\d{4}):(\d{2}):(\d{2})/, '$1-$2-$3'));
                        if (dA < dB) return -1;
                        if (dA > dB) return 1;
                    } else if (dateA) {
                        return -1; // A has date, B doesn't, A comes first
                    } else if (dateB) {
                        return 1;  // B has date, A doesn't, B comes first
                    }
                    return a.name.localeCompare(b.name);
                });
            },

            get currentPagesToDisplay() {
                if (!this.album.pages || this.album.pages.length === 0) return [];
                const page = this.album.pages[this.currentPageIndex];
                if (!page) return [];

                if (this.isFirstPage(this.currentPageIndex) || this.isLastPage(this.currentPageIndex)) {
                    return [page];
                } else {
                    // Double page spread
                    const rightPage = this.album.pages[this.currentPageIndex + 1];
                    return rightPage ? [page, rightPage] : [page]; // Should always find rightPage unless at very end
                }
            },

            // Methods
            initApp() {
                if (!window.showDirectoryPicker) {
                    this.error = "File System Access API is not supported in this browser. Please use a compatible browser like Chrome.";
                    return;
                }
                window.addEventListener('resize', () => this.calculateScaleFactor());
                
                // Setup document-level listeners for resizing
                document.addEventListener('mousemove', (e) => this.handleResizeMouseMove(e));
                document.addEventListener('mouseup', (e) => this.handleResizeMouseUp(e));

                // Close layout menu on outside click
                document.addEventListener('click', (e) => {
                    if (this.layoutMenu.visible && !e.target.closest('.layout-change-button') && !e.target.closest('.layout-menu')) {
                        this.layoutMenu.visible = false;
                    }
                });
            },

            async selectFolder() {
                this.error = '';
                this.isLoading = true;
                try {
                    this.directoryHandle = await window.showDirectoryPicker();
                    await this.loadImagesFromFolder();
                    await this.loadOrCreateAlbum();
                } catch (err) {
                    console.error("Error selecting folder:", err);
                    this.error = "Failed to select folder or access files. " + err.message;
                    this.directoryHandle = null;
                } finally {
                    this.isLoading = false;
                    this.calculateScaleFactor();
                }
            },

            async loadImagesFromFolder() {
                this.images = [];
                let tempImages = [];
                for await (const entry of this.directoryHandle.values()) {
                    if (entry.kind === 'file' && (entry.name.toLowerCase().endsWith('.jpg') || entry.name.toLowerCase().endsWith('.jpeg'))) {
                        const file = await entry.getFile();
                        const url = URL.createObjectURL(file);
                        
                        // Get natural dimensions
                        const naturalDims = await new Promise(resolve => {
                            const img = new Image();
                            img.onload = () => resolve({width: img.naturalWidth, height: img.naturalHeight});
                            img.onerror = () => resolve({width:0, height:0}); // Should handle error
                            img.src = url;
                        });

                        // Read EXIF
                        const exifData = await new Promise(resolve => {
                            EXIF.getData(file, function() {
                                resolve(EXIF.getAllTags(this));
                            });
                        });
                        tempImages.push({ path: entry.name, name: entry.name, url: url, exifData: exifData, used: false, naturalWidth: naturalDims.width, naturalHeight: naturalDims.height });
                    }
                }
                this.images = tempImages;
                if (this.images.length === 0) {
                    this.error = "No JPEG images found in the selected folder. Please select another folder.";
                }
            },

            async loadOrCreateAlbum() {
                try {
                    const fileHandle = await this.directoryHandle.getFileHandle('album.json');
                    const file = await fileHandle.getFile();
                    const contents = await file.text();
                    const loadedAlbum = JSON.parse(contents);

                    if (loadedAlbum.photobook_version !== PHOTOBOOK_VERSION) {
                        this.error = `The existing album.json has version ${loadedAlbum.photobook_version}, which is incompatible with the current version ${PHOTOBOOK_VERSION}. Please remove or backup album.json and reload.`;
                        this.album.pages = []; // Prevent rendering old data
                        return;
                    }
                    this.album = loadedAlbum;
                    this.markUsedImages();

                } catch (e) { // Not found or other error
                    console.log("album.json not found or error reading, creating new album.", e.message);
                    this.createNewAlbum();
                    await this.saveAlbum();
                }
                this.currentPageIndex = 0;
                this.calculateScaleFactor();
            },

            createNewAlbum() {
                this.album = { photobook_version: PHOTOBOOK_VERSION, pages: [] };
                // Page 0: single, layout "1"
                this.album.pages.push(this.createPage("1"));
                // Page 1 & 2: double, layout "2-3" and "3-2"
                this.album.pages.push(this.createPage("2-3"));
                this.album.pages.push(this.createPage("3-2"));
                // Page 3 & 4: double, layout "2-3" and "3-2"
                this.album.pages.push(this.createPage("2-3"));
                this.album.pages.push(this.createPage("3-2"));
                // Page 5: single, layout "1"
                this.album.pages.push(this.createPage("1"));
                this.currentPageIndex = 0;
            },

            createPage(layoutName) {
                const layout = JSON.parse(JSON.stringify(LAYOUT_DEFINITIONS[layoutName])); // Deep copy
                return {
                    id: generateUUID(),
                    layout: layoutName,
                    rows: layout.rows.map(row => ({
                        height_percent: row.height_percent,
                        columns: row.columns.map(col => ({
                            width_grid: col.width_grid,
                            path: null, x: 0, y: 0, width: 0, height: 0
                        }))
                    }))
                };
            },
            
            async saveAlbum() {
                if (!this.directoryHandle) return;
                this.isLoading = true;
                try {
                    const fileHandle = await this.directoryHandle.getFileHandle('album.json', { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(JSON.stringify(this.album, null, 2));
                    await writable.close();
                } catch (err) {
                    console.error("Error saving album:", err);
                    this.error = "Failed to save album.json: " + err.message;
                } finally {
                    this.isLoading = false;
                }
            },

            markUsedImages() {
                const usedPaths = new Set();
                this.album.pages.forEach(page => {
                    page.rows.forEach(row => {
                        row.columns.forEach(col => {
                            if (col.path) usedPaths.add(col.path);
                        });
                    });
                });
                this.images.forEach(img => img.used = usedPaths.has(img.path));
            },

            updateImageUsage(imagePath, isUsed) {
                const img = this.images.find(i => i.path === imagePath);
                if (img) img.used = isUsed;
            },

            // UI Calculations
            calculateScaleFactor() {
                if (!this.$refs.mainArea || this.album.pages.length === 0) {
                    this.scaleFactor = 1; // Default if no content to scale
                    return;
                }
                const mainAreaWidth = this.$refs.mainArea.clientWidth;
                const mainAreaHeight = this.$refs.mainArea.clientHeight;

                const isDouble = this.currentPagesToDisplay.length === 2;
                const targetWidthPx = (isDouble ? 2 * PAGE_WIDTH_CM : PAGE_WIDTH_CM) * PX_PER_CM;
                const targetHeightPx = PAGE_HEIGHT_CM * PX_PER_CM;
                
                if (targetWidthPx === 0 || targetHeightPx === 0) {
                     this.scaleFactor = 1; return;
                }

                this.scaleFactor = Math.min(mainAreaWidth / targetWidthPx, mainAreaHeight / targetHeightPx) * 0.95; // 0.95 for some padding
            },

            getScalerStyle() {
                return `transform: scale(${this.scaleFactor});`;
            },

            getPageStyle() {
                return {
                    width: `${PAGE_WIDTH_CM}cm`,
                    height: `${PAGE_HEIGHT_CM}cm`,
                    // marginRight: this.currentPagesToDisplay.length === 2 ? '1cm' : '0' // Visual gap between double pages
                };
            },
            
            get drawablePageHeightCm() {
                return PAGE_HEIGHT_CM - 2 * PAGE_MARGIN_CM;
            },
            get drawablePageWidthCm() {
                return PAGE_WIDTH_CM - 2 * PAGE_MARGIN_CM;
            },

            getRowStyle(page, rowIndex) {
                const row = page.rows[rowIndex];
                const numRowGutters = page.rows.length - 1;
                const totalGutterHeightCm = numRowGutters > 0 ? numRowGutters * GUTTER_CM : 0;
                const heightForRowsCm = this.drawablePageHeightCm - totalGutterHeightCm;
                
                return {
                    height: `${(row.height_percent / 100) * heightForRowsCm}cm`,
                    display: 'flex'
                };
            },

            getColumnStyle(page, rowIndex, colIndex) {
                const col = page.rows[rowIndex].columns[colIndex];
                const numColGutters = page.rows[rowIndex].columns.length - 1;
                const totalGutterWidthCm = numColGutters > 0 ? numColGutters * GUTTER_CM : 0;
                const widthForColsCm = this.drawablePageWidthCm - totalGutterWidthCm;

                return {
                    width: `${(col.width_grid / TOTAL_GRID_UNITS) * widthForColsCm}cm`,
                    flexGrow: col.width_grid // Allow flex to distribute space based on grid units
                };
            },
            
            // Gutters positioning (simplified, assumes page-content is the reference)
            // These need to be calculated relative to their container (page-content or row)
            // For simplicity, I'll make gutters part of the flex flow (margin-bottom/right on row/col)
            // The draggable gutters will be absolutely positioned over these visual gaps.
            getRowGutterStyle(page, rowIndex) {
                const row = page.rows[rowIndex];
                const numRowGutters = page.rows.length - 1;
                const totalGutterHeightCm = numRowGutters > 0 ? numRowGutters * GUTTER_CM : 0;
                const heightForRowsCm = this.drawablePageHeightCm - totalGutterHeightCm;
                
                let topOffsetCm = 0;
                for (let i = 0; i <= rowIndex; i++) {
                    topOffsetCm += (page.rows[i].height_percent / 100) * heightForRowsCm;
                    if (i < rowIndex) topOffsetCm += GUTTER_CM;
                }

                return {
                    top: `${topOffsetCm}cm`, // Positioned from top of page-content
                    left: `0cm`,
                    width: `${this.drawablePageWidthCm}cm`, // Span full drawable width
                    height: `${GUTTER_CM}cm`,
                };
            },

            getColGutterStyle(page, rowIndex, colIndex) {
                const row = page.rows[rowIndex];
                const numColGutters = row.columns.length - 1;
                const totalGutterWidthCm = numColGutters > 0 ? numColGutters * GUTTER_CM : 0;
                const widthForColsCm = this.drawablePageWidthCm - totalGutterWidthCm;

                let leftOffsetCm = 0;
                for (let i = 0; i <= colIndex; i++) {
                    leftOffsetCm += (row.columns[i].width_grid / TOTAL_GRID_UNITS) * widthForColsCm;
                    if (i < colIndex) leftOffsetCm += GUTTER_CM;
                }
                
                // Height of the gutter is the height of the current row
                const numRowGutters = page.rows.length - 1;
                const totalRowGutterHeightCm = numRowGutters > 0 ? numRowGutters * GUTTER_CM : 0;
                const heightForRowsCm = this.drawablePageHeightCm - totalRowGutterHeightCm;
                const rowHeightCm = (row.height_percent / 100) * heightForRowsCm;

                return {
                    top: `0cm`, // Relative to the start of the row
                    left: `${leftOffsetCm}cm`, // Positioned from left of the row
                    width: `${GUTTER_CM}cm`,
                    height: `${rowHeightCm}cm`, // Span full row height
                    position: 'absolute', // This needs to be relative to the .page-row
                };
            },


            // Image display
            getImageByPath(path) {
                return this.images.find(img => img.path === path);
            },
            imageExists(path) {
                return !!this.getImageByPath(path);
            },

            getCroppedImageStyle(col, page, rowIndex, colIndex) {
                if (!col.path || !col.width || !col.height) return {};
                const image = this.getImageByPath(col.path);
                if (!image || !image.naturalWidth || !image.naturalHeight) return {};

                // Get cell dimensions in pixels (unscaled)
                const pageContentEl = document.querySelector(`.page[data-page-id="${page.id}"] .page-content`); // This might be tricky with x-for
                // For now, approximate using CM values. This is where precise pixel calculation is needed.
                // The cell's actual rendered width/height (W_cell_px, H_cell_px) is needed.
                // Let's assume getColumnStyle gives us the correct relative size.
                // We need the actual pixel dimensions of the cell *before* scaling by scaleFactor.
                
                // This is a placeholder. A more robust way to get cell dimensions is needed.
                // One way: use $refs on cells and getBoundingClientRect, then adjust for scaleFactor.
                // For now, we'll calculate based on cm and PX_PER_CM.
                const numColGutters = page.rows[rowIndex].columns.length - 1;
                const totalColGutterWidthCm = numColGutters > 0 ? numColGutters * GUTTER_CM : 0;
                const widthForColsCm = this.drawablePageWidthCm - totalColGutterWidthCm;
                const cellWidthPx = (col.width_grid / TOTAL_GRID_UNITS) * widthForColsCm * PX_PER_CM;

                const numRowGutters = page.rows.length - 1;
                const totalRowGutterHeightCm = numRowGutters > 0 ? numRowGutters * GUTTER_CM : 0;
                const heightForRowsCm = this.drawablePageHeightCm - totalRowGutterHeightCm;
                const cellHeightPx = (page.rows[rowIndex].height_percent / 100) * heightForRowsCm * PX_PER_CM;


                if (cellWidthPx === 0 || cellHeightPx === 0) return {};

                const imgOriginalWidth = image.naturalWidth;
                const imgOriginalHeight = image.naturalHeight;
                const cropData = col; // {x, y, width, height} on original image

                // Scale factor for the image itself to fit its cropped part into the cell
                const scaleX = cellWidthPx / cropData.width;
                const scaleY = cellHeightPx / cropData.height;
                // To fill, we usually pick Math.max(scaleX, scaleY) if we were center cropping.
                // But here, the cropData *defines* what part of image maps to cell.
                // So, the image needs to be scaled such that cropData.width maps to cellWidthPx.
                
                const finalImgWidth = imgOriginalWidth * scaleX;
                const finalImgHeight = imgOriginalHeight * scaleY; // Should be imgOriginalHeight * scaleX if aspect ratio is maintained by crop.
                                                                 // Or, if crop can be non-uniform, then use scaleY for height.
                                                                 // Let's assume crop maintains aspect of cell.
                                                                 // The crop data (x,y,width,height) IS the part of the original image.
                                                                 // So, we scale this part to fit the cell.
                
                const displayWidth = (imgOriginalWidth / cropData.width) * cellWidthPx;
                const displayHeight = (imgOriginalHeight / cropData.height) * cellHeightPx;

                const offsetX = -(cropData.x / cropData.width) * cellWidthPx;
                const offsetY = -(cropData.y / cropData.height) * cellHeightPx;

                return {
                    width: `${displayWidth}px`,
                    height: `${displayHeight}px`,
                    left: `${offsetX}px`,
                    top: `${offsetY}px`,
                    position: 'absolute', // Ensure this is set
                };
            },

            autoCropAndFill(pageId, rowIndex, colIndex, imagePath) {
                const page = this.album.pages.find(p => p.id === pageId);
                if (!page) return;
                const cell = page.rows[rowIndex].columns[colIndex];
                const image = this.getImageByPath(imagePath);
                if (!image || !image.naturalWidth || !image.naturalHeight) return;

                // Calculate cell aspect ratio
                // This is complex because cell dimensions depend on other cells/rows.
                // For simplicity, let's get current cell dimensions in pixels (unscaled)
                // This is a rough estimation.
                const numColGutters = page.rows[rowIndex].columns.length - 1;
                const totalColGutterWidthCm = numColGutters > 0 ? numColGutters * GUTTER_CM : 0;
                const widthForColsCm = this.drawablePageWidthCm - totalColGutterWidthCm;
                const cellWidthCm = (cell.width_grid / TOTAL_GRID_UNITS) * widthForColsCm;

                const numRowGutters = page.rows.length - 1;
                const totalRowGutterHeightCm = numRowGutters > 0 ? numRowGutters * GUTTER_CM : 0;
                const heightForRowsCm = this.drawablePageHeightCm - totalRowGutterHeightCm;
                const cellHeightCm = (page.rows[rowIndex].height_percent / 100) * heightForRowsCm;

                if (cellWidthCm === 0 || cellHeightCm === 0) return; // Avoid division by zero
                const cellAspectRatio = cellWidthCm / cellHeightCm;
                
                const imgWidth = image.naturalWidth;
                const imgHeight = image.naturalHeight;
                const imgAspectRatio = imgWidth / imgHeight;

                let crop = { x: 0, y: 0, width: imgWidth, height: imgHeight };

                if (imgAspectRatio > cellAspectRatio) { // Image is wider than cell (proportionally)
                    crop.width = imgHeight * cellAspectRatio;
                    crop.x = (imgWidth - crop.width) / 2;
                } else { // Image is taller than cell (proportionally)
                    crop.height = imgWidth / cellAspectRatio;
                    crop.y = (imgHeight - crop.height) / 2;
                }
                
                cell.x = Math.round(crop.x);
                cell.y = Math.round(crop.y);
                cell.width = Math.round(crop.width);
                cell.height = Math.round(crop.height);
            },

            // Navigation
            isFirstPage(pageArrayIndex) { return pageArrayIndex === 0; },
            isLastPage(pageArrayIndex) { return pageArrayIndex === this.album.pages.length - 1; },
            
            canGoPrev() { return this.currentPageIndex > 0; },
            prevPage() {
                if (!this.canGoPrev()) return;
                if (this.isFirstPage(this.currentPageIndex) || this.isFirstPage(this.currentPageIndex -1)) { // From page 0 or from page 2&3 to page 0
                     this.currentPageIndex = 0;
                } else {
                     this.currentPageIndex -= 2; // Move by a spread
                }
                this.calculateScaleFactor();
                this.layoutMenu.visible = false;
            },

            canGoNext() {
                if (this.album.pages.length === 0) return false;
                // If current is single last page
                if (this.isLastPage(this.currentPageIndex) && (this.currentPageIndex === 0 || this.album.pages[this.currentPageIndex-1])) {
                    return false;
                }
                // If current is a double spread, check if there's another spread or single last page
                if (!this.isLastPage(this.currentPageIndex) && !this.isLastPage(this.currentPageIndex + 1)) {
                    return this.currentPageIndex + 2 < this.album.pages.length;
                }
                return false; // Should be covered by above
            },
            nextPage() {
                if (!this.canGoNext()) return;
                if (this.isFirstPage(this.currentPageIndex)) { // From page 0 to 1&2
                    this.currentPageIndex = 1;
                } else {
                    this.currentPageIndex += 2; // Move by a spread
                }
                this.calculateScaleFactor();
                this.layoutMenu.visible = false;
            },

            getPageNumberText() {
                if (this.album.pages.length === 0) return "";
                const totalPages = this.album.pages.length;
                const current = this.album.pages[this.currentPageIndex];
                const pageNumberCurrent = this.album.pages.indexOf(current) + 1;

                if (this.isFirstPage(this.currentPageIndex) || this.isLastPage(this.currentPageIndex)) {
                    return `Page ${pageNumberCurrent}/${totalPages}`;
                } else {
                    const rightPage = this.album.pages[this.currentPageIndex + 1];
                    const pageNumberRight = this.album.pages.indexOf(rightPage) + 1;
                    return `Pages ${pageNumberCurrent}-${pageNumberRight}/${totalPages}`;
                }
            },

            // Page Operations
            canAddPage() {
                // Cannot add if current view includes the actual last page of the book
                if (this.album.pages.length === 0) return true; // Can add to empty album
                if (this.isLastPage(this.currentPageIndex)) return false; // On single last page
                if (this.currentPagesToDisplay.length === 2 && this.isLastPage(this.currentPageIndex + 1)) return false; // On double spread that is last
                return true;
            },
            addPage() {
                if (!this.canAddPage()) return;
                const newPage1 = this.createPage("2-2"); // Default layout for new pages
                const newPage2 = this.createPage("2-2");
                
                let insertAtIndex;
                if (this.album.pages.length === 0) {
                    insertAtIndex = 0; // Should not happen if createNewAlbum runs
                } else if (this.isFirstPage(this.currentPageIndex)) { // After first single page
                    insertAtIndex = this.currentPageIndex + 1;
                } else { // After a double page spread
                    insertAtIndex = this.currentPageIndex + 2;
                }
                
                this.album.pages.splice(insertAtIndex, 0, newPage1, newPage2);
                // Navigate to the newly added pages? Or stay? Let's stay. If navigate:
                // this.currentPageIndex = insertAtIndex;
                this.saveAlbum();
            },

            isCurrentViewDoublePage() {
                return !this.isFirstPage(this.currentPageIndex) && !this.isLastPage(this.currentPageIndex) && this.album.pages[this.currentPageIndex+1];
            },

            canMovePage() {
                return this.isCurrentViewDoublePage();
            },
            canMovePageLeft() {
                if (!this.canMovePage()) return false;
                // Cannot move if it's the first double page (i.e., pages 2&3, index 1)
                return this.currentPageIndex > 1; 
            },
            canMovePageRight() {
                if (!this.canMovePage()) return false;
                // Cannot move if it's the last double page
                // (i.e., pages N-2 & N-1, index is album.pages.length - 3, if last page is single)
                return this.currentPageIndex + 2 < this.album.pages.length - 1;
            },
            movePageRelative(direction) { // direction: -1 for left, 1 for right
                if ((direction === -1 && !this.canMovePageLeft()) || (direction === 1 && !this.canMovePageRight())) return;

                const page1 = this.album.pages[this.currentPageIndex];
                const page2 = this.album.pages[this.currentPageIndex + 1];
                
                // Remove
                this.album.pages.splice(this.currentPageIndex, 2);
                
                // New index to insert at
                const newInsertIndex = this.currentPageIndex + (direction * 2);
                
                // Insert
                this.album.pages.splice(newInsertIndex, 0, page1, page2);
                
                this.currentPageIndex = newInsertIndex;
                this.saveAlbum();
            },

            canDeletePage() {
                // Can only delete double pages
                return this.isCurrentViewDoublePage();
            },
            deleteCurrentPage() {
                if (!this.canDeletePage()) return;
                if (confirm("Are you sure you want to delete these two pages?")) {
                    this.album.pages.splice(this.currentPageIndex, 2);
                    // Adjust currentPageIndex: move to previous spread, or first page if no previous spread
                    if (this.currentPageIndex >= this.album.pages.length) { // If last spread was deleted
                        this.currentPageIndex = Math.max(0, this.album.pages.length - (this.album.pages.length % 2 === 0 ? 2 : 1) );
                         if (this.isLastPage(this.currentPageIndex) && this.album.pages.length > 1 && !this.isFirstPage(this.currentPageIndex)) {
                            // if it lands on the last single page, and it's not the only page, try to go to the spread before it
                            this.currentPageIndex = Math.max(0, this.currentPageIndex - (this.isLastPage(this.currentPageIndex-1) ? 1:2) );
                         } else if (this.album.pages.length === 1) {
                            this.currentPageIndex = 0;
                         }
                    } else if (this.currentPageIndex > 0 && !this.isFirstPage(this.currentPageIndex-1)) {
                        // Try to go to previous spread
                        this.currentPageIndex = Math.max(0, this.currentPageIndex -2);
                        if (this.isFirstPage(this.currentPageIndex) && this.currentPageIndex !== 0) this.currentPageIndex = 0; // safety
                    } else {
                        this.currentPageIndex = 0; // Default to first page
                    }


                    if (this.album.pages.length > 0 && this.isLastPage(this.currentPageIndex) && this.currentPageIndex % 2 === 0 && this.currentPageIndex !== 0) {
                        // If we landed on a left page that is now the last page, it should be a single page view.
                        // This logic needs to be robust. For now, simple adjustment.
                        this.currentPageIndex = Math.max(0, this.currentPageIndex);
                    } else if (this.album.pages.length > 0 && this.currentPageIndex % 2 !== 0 && !this.isFirstPage(this.currentPageIndex)) {
                        // If we landed on a right page of a non-existent spread, adjust.
                         this.currentPageIndex = Math.max(0, this.currentPageIndex -1);
                    }


                    this.calculateScaleFactor();
                    this.saveAlbum();
                }
            },
            
            // Drag and Drop
            handleDragStartFromBank(event, image) {
                if (image.used) {
                    event.preventDefault(); // Don't allow dragging used images from bank
                    return;
                }
                this.draggedImage = { type: 'bank', ...image };
                event.dataTransfer.setData('text/plain', image.path);
                event.dataTransfer.effectAllowed = 'copy';
            },
            handleDragStartFromCell(event, pageId, rowIndex, colIndex, imagePath) {
                this.draggedImage = { type: 'cell', pageId, rowIndex, colIndex, path: imagePath };
                event.dataTransfer.setData('text/plain', imagePath); // Could also stringify the object
                event.dataTransfer.effectAllowed = 'move';
            },

            handleDragOverCell(event, pageId, rowIndex, colIndex) {
                event.preventDefault(); // Necessary to allow drop
                // Add visual feedback if needed (e.g., highlight cell)
            },
            handleDragLeaveCell(event, pageId, rowIndex, colIndex) {
                // Remove visual feedback
            },

            handleDropOnCell(event, targetPageId, targetRowIndex, targetColIndex) {
                event.preventDefault();
                if (!this.draggedImage) return;

                const targetPage = this.album.pages.find(p => p.id === targetPageId);
                if (!targetPage) return;
                const targetCell = targetPage.rows[targetRowIndex].columns[targetColIndex];

                if (this.draggedImage.type === 'bank') {
                    const imagePath = this.draggedImage.path;
                    if (targetCell.path) { // Cell already has an image, return it to bank
                        this.updateImageUsage(targetCell.path, false);
                    }
                    targetCell.path = imagePath;
                    this.autoCropAndFill(targetPageId, targetRowIndex, targetColIndex, imagePath);
                    this.updateImageUsage(imagePath, true);
                } else if (this.draggedImage.type === 'cell') {
                    // Moving from another cell
                    const sourcePage = this.album.pages.find(p => p.id === this.draggedImage.pageId);
                    if (!sourcePage) return;
                    const sourceCell = sourcePage.rows[this.draggedImage.rowIndex].columns[this.draggedImage.colIndex];

                    if (sourceCell === targetCell) { // Dropped on itself
                        this.draggedImage = null;
                        return;
                    }

                    // Swap content
                    const tempPath = targetCell.path;
                    const tempCrop = { x: targetCell.x, y: targetCell.y, width: targetCell.width, height: targetCell.height };

                    targetCell.path = sourceCell.path;
                    targetCell.x = sourceCell.x; targetCell.y = sourceCell.y; targetCell.width = sourceCell.width; targetCell.height = sourceCell.height;
                    
                    sourceCell.path = tempPath;
                    sourceCell.x = tempCrop.x; sourceCell.y = tempCrop.y; sourceCell.width = tempCrop.width; sourceCell.height = tempCrop.height;
                    
                    // If one was empty, ensure usage is updated
                    if (targetCell.path && !sourceCell.path) { // Moved image to an empty cell, old cell is now empty
                        // No change in usage count needed
                    } else if (!targetCell.path && sourceCell.path) { // Target was empty, source had image (now target has it)
                        // No change in usage count needed
                    }
                    // If both had images, they just swapped, usage count fine.
                }
                this.draggedImage = null;
                this.saveAlbum();
            },

            handleDropOnImageBank(event) {
                event.preventDefault();
                if (this.draggedImage && this.draggedImage.type === 'cell') {
                    const sourcePage = this.album.pages.find(p => p.id === this.draggedImage.pageId);
                    if (!sourcePage) return;
                    const sourceCell = sourcePage.rows[this.draggedImage.rowIndex].columns[this.draggedImage.colIndex];
                    
                    this.updateImageUsage(sourceCell.path, false);
                    sourceCell.path = null;
                    sourceCell.x = 0; sourceCell.y = 0; sourceCell.width = 0; sourceCell.height = 0;
                    
                    this.draggedImage = null;
                    this.saveAlbum();
                }
            },
            handleDropOnMainArea(event) { // Catch drops outside specific zones, e.g. to image bank
                if (this.draggedImage && this.draggedImage.type === 'cell') {
                    // Simulates dropping on image bank if dropped on gray area
                    this.handleDropOnImageBank(event);
                }
            },

            goToPageOfImage(imagePath) {
                for (let i = 0; i < this.album.pages.length; i++) {
                    const page = this.album.pages[i];
                    for (const row of page.rows) {
                        for (const col of row.columns) {
                            if (col.path === imagePath) {
                                // Determine if this page is a left or right of a spread, or single
                                if (this.isFirstPage(i) || this.isLastPage(i)) {
                                    this.currentPageIndex = i;
                                } else {
                                    // It's part of a spread. If i is odd, it's a left page. If i is even, it's a right page.
                                    this.currentPageIndex = (i % 2 !== 0) ? i : i - 1;
                                }
                                this.calculateScaleFactor();
                                this.layoutMenu.visible = false;
                                return;
                            }
                        }
                    }
                }
            },

            // Cropping
            openCropper(pageId, rowIndex, colIndex, imagePath) {
                const page = this.album.pages.find(p => p.id === pageId);
                const cell = page.rows[rowIndex].columns[colIndex];
                const image = this.getImageByPath(imagePath);
                if (!image || !image.url) return;

                // Calculate cell aspect ratio for Croppie viewport
                const numColGutters = page.rows[rowIndex].columns.length - 1;
                const totalColGutterWidthCm = numColGutters > 0 ? numColGutters * GUTTER_CM : 0;
                const widthForColsCm = this.drawablePageWidthCm - totalColGutterWidthCm;
                const cellWidthCm = (cell.width_grid / TOTAL_GRID_UNITS) * widthForColsCm;

                const numRowGutters = page.rows.length - 1;
                const totalRowGutterHeightCm = numRowGutters > 0 ? numRowGutters * GUTTER_CM : 0;
                const heightForRowsCm = this.drawablePageHeightCm - totalRowGutterHeightCm;
                const cellHeightCm = (page.rows[rowIndex].height_percent / 100) * heightForRowsCm;
                
                const vpWidth = 300; // Viewport width for Croppie
                const vpHeight = (cellHeightCm / cellWidthCm) * vpWidth;

                this.croppingImageInfo = { pageId, rowIndex, colIndex, path: imagePath, cellAspectRatio: cellWidthCm / cellHeightCm };
                this.showCropperModal = true;

                this.$nextTick(() => {
                    if (this.croppieInstance) this.croppieInstance.destroy();
                    this.croppieInstance = new Croppie(this.$refs.croppieEl, {
                        url: image.url,
                        viewport: { width: vpWidth, height: vpHeight, type: 'square' }, // type 'square' forces aspect ratio
                        boundary: { width: vpWidth + 100, height: vpHeight + 100 },
                        enableOrientation: true,
                        enableZoom: true,
                        mouseWheelZoom: true,
                    });
                    // If existing crop data, bind it
                    if (cell.width && cell.height) {
                        // Croppie points: [topLeftX, topLeftY, bottomRightX, bottomRightY] in original image pixels
                        const points = [cell.x, cell.y, cell.x + cell.width, cell.y + cell.height];
                        this.croppieInstance.bind({ url: image.url, points: points });
                    } else {
                         this.croppieInstance.bind({ url: image.url }); // Default bind
                    }
                });
            },
            async saveCrop() {
                if (!this.croppieInstance || !this.croppingImageInfo) return;
                const result = await this.croppieInstance.result({
                    type: 'rawcanvas', // Gives coordinates on original image
                    size: 'original', // Coordinates relative to original image size
                    format: 'jpeg' 
                });
                
                const page = this.album.pages.find(p => p.id === this.croppingImageInfo.pageId);
                const cell = page.rows[this.croppingImageInfo.rowIndex].columns[this.croppingImageInfo.colIndex];
                
                // result.points contains [x1, y1, x2, y2] of the crop area on the original image
                cell.x = Math.round(result.points[0]);
                cell.y = Math.round(result.points[1]);
                cell.width = Math.round(result.points[2] - result.points[0]);
                cell.height = Math.round(result.points[3] - result.points[1]);

                this.closeCropper();
                this.saveAlbum();
            },
            closeCropper() {
                if (this.croppieInstance) this.croppieInstance.destroy();
                this.croppieInstance = null;
                this.croppingImageInfo = null;
                this.showCropperModal = false;
            },

            // Layout Change
            isPageSingleType(page) { // Check if page is inherently single (first or last)
                const pageIndex = this.album.pages.findIndex(p => p.id === page.id);
                return this.isFirstPage(pageIndex) || this.isLastPage(pageIndex);
            },
            isLeftPage(pageArrayIndexInDisplay) { // pageArrayIndexInDisplay is 0 for left/single, 1 for right
                return pageArrayIndexInDisplay === 0;
            },
            isRightPage(pageArrayIndexInDisplay) {
                return this.currentPagesToDisplay.length === 2 && pageArrayIndexInDisplay === 1;
            },
            toggleLayoutMenu(pageId, isLeft) {
                const page = this.album.pages.find(p => p.id === pageId);
                if (this.isPageSingleType(page)) return; // No layout change for first/last physical pages

                if (this.layoutMenu.visible && this.layoutMenu.pageId === pageId) {
                    this.layoutMenu.visible = false;
                } else {
                    this.layoutMenu.visible = true;
                    this.layoutMenu.pageId = pageId;
                    this.layoutMenu.isLeft = isLeft; // Not strictly needed if pageId is unique
                }
            },
            changePageLayout(pageId, newLayoutName) {
                const page = this.album.pages.find(p => p.id === pageId);
                if (!page || this.isPageSingleType(page)) return; // Cannot change layout of first/last page

                const oldLayoutName = page.layout;
                if (oldLayoutName === newLayoutName) {
                    this.layoutMenu.visible = false;
                    return;
                }

                const newLayoutDefinition = JSON.parse(JSON.stringify(LAYOUT_DEFINITIONS[newLayoutName]));
                
                // Collect existing images from the page
                let existingImages = [];
                page.rows.forEach(row => row.columns.forEach(col => {
                    if (col.path) existingImages.push({...col});
                }));

                // Apply new layout structure
                page.layout = newLayoutName;
                page.rows = newLayoutDefinition.rows.map(rDef => ({
                    height_percent: rDef.height_percent,
                    columns: rDef.columns.map(cDef => ({
                        width_grid: cDef.width_grid,
                        path: null, x:0, y:0, width:0, height:0
                    }))
                }));

                // Logic for redistributing images (simplified)
                // Rule of thumb: keep as much as possible.
                // From any to "1": Keep first image found.
                if (newLayoutName === "1") {
                    if (existingImages.length > 0) {
                        const firstImage = existingImages[0];
                        page.rows[0].columns[0].path = firstImage.path;
                        page.rows[0].columns[0].x = firstImage.x;
                        page.rows[0].columns[0].y = firstImage.y;
                        page.rows[0].columns[0].width = firstImage.width;
                        page.rows[0].columns[0].height = firstImage.height;
                        // Return other images to bank
                        existingImages.slice(1).forEach(imgCol => this.updateImageUsage(imgCol.path, false));
                        // Auto-recrop the kept image
                        this.autoCropAndFill(page.id, 0, 0, firstImage.path);
                    }
                } 
                // From "1" to any: Place image in top-left.
                else if (oldLayoutName === "1" && existingImages.length > 0) {
                    const imageToPlace = existingImages[0];
                    page.rows[0].columns[0].path = imageToPlace.path;
                    page.rows[0].columns[0].x = imageToPlace.x;
                    page.rows[0].columns[0].y = imageToPlace.y;
                    page.rows[0].columns[0].width = imageToPlace.width;
                    page.rows[0].columns[0].height = imageToPlace.height;
                    this.autoCropAndFill(page.id, 0, 0, imageToPlace.path);
                }
                // Other transitions: try to fill cells top-to-bottom, left-to-right
                else {
                    let imgIdx = 0;
                    for (let r = 0; r < page.rows.length; r++) {
                        for (let c = 0; c < page.rows[r].columns.length; c++) {
                            if (imgIdx < existingImages.length) {
                                const imgData = existingImages[imgIdx++];
                                page.rows[r].columns[c].path = imgData.path;
                                page.rows[r].columns[c].x = imgData.x;
                                page.rows[r].columns[c].y = imgData.y;
                                page.rows[r].columns[c].width = imgData.width;
                                page.rows[r].columns[c].height = imgData.height;
                                this.autoCropAndFill(page.id, r, c, imgData.path);
                            } else {
                                break; // No more images to place
                            }
                        }
                        if (imgIdx >= existingImages.length) break;
                    }
                    // Return unused images to bank
                    if (imgIdx < existingImages.length) {
                        existingImages.slice(imgIdx).forEach(imgCol => this.updateImageUsage(imgCol.path, false));
                    }
                }
                
                // Specific rules from spec (this part needs careful integration with above generic logic)
                // Example: "from "2-3" to "2-2". Drop the 3rd image in the top row."
                // The generic logic above is a simpler catch-all. The spec's rules are more granular.
                // For brevity, I'm using the generic fill. A full implementation would need if/else for each specific transition.

                this.layoutMenu.visible = false;
                this.markUsedImages(); // Re-check all used images
                this.saveAlbum();
            },

            // Resizing (Custom Implementation)
            initRowResize(event, pageId, rowIndex) {
                event.preventDefault();
                const page = this.album.pages.find(p => p.id === pageId);
                if (!page || page.rows.length !== 2) return; // Only support 2-row resize for now

                this.resizing = {
                    type: 'row',
                    pageId: pageId,
                    rowIndex: rowIndex, // Gutter is AFTER this row
                    initialMouseY: event.clientY,
                    initialRow1HeightPercent: page.rows[0].height_percent,
                    initialRow2HeightPercent: page.rows[1].height_percent,
                };
            },

            initColResize(event, pageId, rowIndex, colIndex) {
                event.preventDefault();
                const page = this.album.pages.find(p => p.id === pageId);
                if (!page) return;
                const row = page.rows[rowIndex];
                if (colIndex >= row.columns.length -1) return; // No gutter after last column

                this.resizing = {
                    type: 'col',
                    pageId: pageId,
                    rowIndex: rowIndex,
                    colIndex: colIndex, // Gutter is AFTER this column
                    initialMouseX: event.clientX,
                    initialCol1WidthGrid: row.columns[colIndex].width_grid,
                    initialCol2WidthGrid: row.columns[colIndex+1].width_grid,
                    // If 3 columns and resizing between 0 and 1, col 2 (index) width is fixed
                    thirdColWidthGrid: (row.columns.length === 3 && colIndex === 0) ? row.columns[2].width_grid : null,
                };
            },

            handleResizeMouseMove(event) {
                if (!this.resizing) return;
                event.preventDefault();

                const page = this.album.pages.find(p => p.id === this.resizing.pageId);
                if (!page) { this.resizing = null; return; }

                if (this.resizing.type === 'row') {
                    const dy = (event.clientY - this.resizing.initialMouseY) / this.scaleFactor; // Unscaled delta
                    
                    // Convert dy to percentage change
                    // Total height available for rows (excluding gutter) in pixels
                    const numRowGutters = page.rows.length - 1;
                    const totalGutterHeightCm = numRowGutters > 0 ? numRowGutters * GUTTER_CM : 0;
                    const heightForRowsCm = this.drawablePageHeightCm - totalGutterHeightCm;
                    const heightForRowsPx = heightForRowsCm * PX_PER_CM;

                    if (heightForRowsPx === 0) return;
                    const dPercent = (dy / heightForRowsPx) * 100;

                    let newRow1Percent = this.resizing.initialRow1HeightPercent + dPercent;
                    let newRow2Percent = this.resizing.initialRow2HeightPercent - dPercent;

                    // Constraints (e.g., min 10%)
                    const minPercent = 10;
                    if (newRow1Percent < minPercent) {
                        newRow1Percent = minPercent;
                        newRow2Percent = 100 - minPercent;
                    } else if (newRow2Percent < minPercent) {
                        newRow2Percent = minPercent;
                        newRow1Percent = 100 - minPercent;
                    }
                    page.rows[0].height_percent = newRow1Percent;
                    page.rows[1].height_percent = newRow2Percent;

                } else if (this.resizing.type === 'col') {
                    const dx = (event.clientX - this.resizing.initialMouseX) / this.scaleFactor; // Unscaled delta
                    const row = page.rows[this.resizing.rowIndex];

                    const numColGutters = row.columns.length - 1;
                    const totalGutterWidthCm = numColGutters > 0 ? numColGutters * GUTTER_CM : 0;
                    const widthForColsCm = this.drawablePageWidthCm - totalGutterWidthCm;
                    const widthForColsPx = widthForColsCm * PX_PER_CM;

                    if (widthForColsPx === 0) return;
                    const dGridUnits = (dx / widthForColsPx) * TOTAL_GRID_UNITS;

                    let newCol1Grid = this.resizing.initialCol1WidthGrid + dGridUnits;
                    let newCol2Grid = this.resizing.initialCol2WidthGrid - dGridUnits;
                    
                    const minGrid = 1; // Min width_grid units

                    if (this.resizing.thirdColWidthGrid !== null) { // Resizing 1&2 of 3 columns
                        const sumFirstTwo = this.resizing.initialCol1WidthGrid + this.resizing.initialCol2WidthGrid;
                        if (newCol1Grid < minGrid) {
                            newCol1Grid = minGrid;
                            newCol2Grid = sumFirstTwo - minGrid;
                        } else if (newCol2Grid < minGrid) {
                            newCol2Grid = minGrid;
                            newCol1Grid = sumFirstTwo - minGrid;
                        }
                        row.columns[this.resizing.colIndex].width_grid = newCol1Grid;
                        row.columns[this.resizing.colIndex + 1].width_grid = newCol2Grid;
                        // row.columns[2].width_grid remains this.resizing.thirdColWidthGrid
                    } else { // Resizing 2 columns, or 2&3 of 3 columns
                        const totalGridForPair = this.resizing.initialCol1WidthGrid + this.resizing.initialCol2WidthGrid;
                         if (newCol1Grid < minGrid) {
                            newCol1Grid = minGrid;
                            newCol2Grid = totalGridForPair - minGrid;
                        } else if (newCol2Grid < minGrid) {
                            newCol2Grid = minGrid;
                            newCol1Grid = totalGridForPair - minGrid;
                        }
                        row.columns[this.resizing.colIndex].width_grid = newCol1Grid;
                        row.columns[this.resizing.colIndex + 1].width_grid = newCol2Grid;
                    }
                }
            },

            handleResizeMouseUp(event) {
                if (!this.resizing) return;
                
                // Auto-recrop images in affected cells
                const page = this.album.pages.find(p => p.id === this.resizing.pageId);
                if (page) {
                    if (this.resizing.type === 'row') {
                        // Recrop all images in row 0 and row 1
                        [0,1].forEach(rIdx => {
                            page.rows[rIdx].columns.forEach((col, cIdx) => {
                                if (col.path) this.autoCropAndFill(page.id, rIdx, cIdx, col.path);
                            });
                        });
                    } else if (this.resizing.type === 'col') {
                        // Recrop images in affected columns
                        const rIdx = this.resizing.rowIndex;
                        const cIdx1 = this.resizing.colIndex;
                        const cIdx2 = this.resizing.colIndex + 1;
                        [cIdx1, cIdx2].forEach(cIdx => {
                             if (page.rows[rIdx].columns[cIdx] && page.rows[rIdx].columns[cIdx].path) {
                                this.autoCropAndFill(page.id, rIdx, cIdx, page.rows[rIdx].columns[cIdx].path);
                             }
                        });
                    }
                }

                this.resizing = null;
                this.saveAlbum();
            },

        }));
    });
    </script>
</body>
</html>